<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🥁 yie&#39;s Blog 🎈</title>
  
  <subtitle>The power of imagination makes us infinite, Welcome to yie&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yieeo.github.io/"/>
  <updated>2018-12-04T15:12:30.000Z</updated>
  <id>https://yieeo.github.io/</id>
  
  <author>
    <name>yie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReactJS JSX</title>
    <link href="https://yieeo.github.io/2018/07/10/ReactJS-JSX/"/>
    <id>https://yieeo.github.io/2018/07/10/ReactJS-JSX/</id>
    <published>2018-07-10T08:59:44.000Z</published>
    <updated>2018-12-04T15:12:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>JSX(JavaScript and XML)是ReactJS定义的一种JavaScript语法扩展. JSX是可选的, 我们完全可以使用JavaScript编写ReactJS应用, 不过JSX提供一套更为简洁的方式来写ReactJS应用.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用JSX</span></span><br><span class="line"><span class="keyword">const</span> bar = (</span><br><span class="line">  &lt;h1 className=<span class="string">'bingo'</span>&gt;</span><br><span class="line">    hello world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用JSX</span></span><br><span class="line"><span class="keyword">const</span> bar = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'bingo'</span> &#125;,</span><br><span class="line">  <span class="string">'hello world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但是JSX有以下优点:</p><ul><li>它更快, 因为它将代码编译为JavaScript时执行优化</li><li>它很安全, 编译期间可以捕获大多数错误</li><li>你熟悉HTML, 可以很轻松, 快速的编写模板</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JSX中括号内允许放置任何有效的JavaScript表达式</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;hello, &#123; name &#125;&lt;/h1&gt;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>当JSX拆分为多行时, 我们应该将其包在一个括号内, 避免浏览器自动插入分号</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以在if语句和for循环中使用JSX, 将其分配给变量, 接收它作为参数, 并从函数返回它</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;hello, &#123; user &#125;!&lt;/h1&gt;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;hello, Mary!&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以使用引号将字符串文字指定为属性</span></span><br><span class="line"><span class="keyword">const</span> bar = &lt;div tabIndex='0'&gt;&lt;/div&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以使用大括号在属性中嵌入JavaScript表达式</span></span><br><span class="line"><span class="keyword">const</span> bar = &lt;img src=&#123; user.name &#125;&gt;&lt;/img&gt;;</span><br></pre></td></tr></table></figure><blockquote><p>在JSX的标签中的同一属性上不能同时使用引号和大括号, JSX中采用<code>cameCase</code>(驼峰式)属性命名约定, <code>class</code>属性应该变成<code>className</code>, <code>tabindex</code>属性应该变成<code>tabIndex</code>, <code>for</code>属性应该变成<code>htmlFor</code>.</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JSX中所有标签都要闭合</span></span><br><span class="line"><span class="keyword">const</span> bar = &lt;img src=&#123; user.name &#125; /&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JSX中的标签可以包含子标签</span></span><br><span class="line"><span class="keyword">const</span> bar = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;what a wonderful world.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JSX中使用注释</span></span><br><span class="line"><span class="keyword">const</span> bar = (</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// comment</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#123;<span class="comment">/* comment */</span>&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      comment</span></span><br><span class="line"><span class="comment">      ...</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;p&gt;what a wonderful world.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>总结:</p><ul><li>在JSX中可以插入任何JavaScript表达式, 表达式需要用<code>{}</code>包裹起来, 插入字符串用<code>&quot;&quot;</code>包裹</li><li>JSX表达式可以像JavaScript对象一样, 可以被赋值, 传参和<code>return</code></li><li>JSX分割成多行时, 需要使用<code>()</code>包裹起来, 避免浏览器自动插入分号</li><li>JSX中的所有标签必须闭合</li><li>JSX属性采用驼峰式命名, <code>class</code>属性应该写成<code>className</code>, <code>tabindex</code>属性应该写成<code>tabIndex</code>, <code>for</code>属性应该写成<code>htmlFor</code></li><li>JSX在渲染之前, 所有东西转换为字符串, 可以防止XSS攻击</li><li>Babel通过调用<code>React.createElement()</code>API来编译JSX, React必须在JSX代码的作用域内</li><li>JSX通过<code>React.createElement()</code>API将JSX转化为React Object</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSX(JavaScript and XML)是ReactJS定义的一种JavaScript语法扩展. JSX是可选的, 我们完全可以使用JavaScript编写ReactJS应用, 不过JSX提供一套更为简洁的方式来写ReactJS应用.&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
      <category term="ReactJS" scheme="https://yieeo.github.io/tags/ReactJS/"/>
    
  </entry>
  
  <entry>
    <title>Learn ReactJS</title>
    <link href="https://yieeo.github.io/2018/06/22/Learn-ReactJS/"/>
    <id>https://yieeo.github.io/2018/06/22/Learn-ReactJS/</id>
    <published>2018-06-22T13:15:55.000Z</published>
    <updated>2018-12-04T15:09:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>ReactJS是Facebook开发的UI库, 这个库有助于创建交互式, 基于状态和可重用的UI库. ReactJS已经用于Facebook自己的Instagram项目. ReactJS不仅可以运行在客户端, 也可以用于服务器端, 从而使客户端和服务器端协同操作.</p><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><p>在Web开发中, 需要不断变化数据实时显示在UI上, 这时就要操作DOM, 复杂频繁操作DOM就会下降Web性能. ReactJS为了解决这个性能瓶颈, 引入了虚拟DOM(Virtual DOM), 这也是ReactJS最为重要的核心机制之一. ReactJS利用虚拟DOM来减少对真实DOM的操作而提升性能. 由于虚拟DOM是在内存中创建的, 性能极高. 它可以根据状态的变化, 有选择的渲染节点和子节点, 为了更新部件, ReactJS做尽量少的DOM处理操作. 开发者不用关心数据是如何变化的, 只需要知道每一次页面渲染对应的整体数据就行了. 在ReactJS的开发中, 你永远只需要关心整体数据. 由于ReactJS使用的是虚拟的DOM, 这就产生一种新的可能, 我们可以在服务器端渲染虚拟的DOM, 快速更新视图.</p><h4 id="组件化思想"><a href="#组件化思想" class="headerlink" title="组件化思想"></a>组件化思想</h4><blockquote><p>组件: 封装起来具有独立功能的UI部件</p></blockquote><p>在虚拟DOM的基础上衍生了ReactJS组件化的开发思路, ReactJS刚出现时, 犹如一记重磅炸弹, 轰动Web前端领域, 原来还可以以这种方式开发网页, ReactJS后来还衍生出了React Native项目, 可以通过Web APP的方式去写Native APP, React Native项目在GitHub平台上发布一天之内获得了5000star. ReactJS先进的设计思想也影响了后来的一些的JS框架和库. VueJS就可以寻到一些ReactJS设计思想的影子.</p><p>ReactJS接管了开发UI中最为复杂的局部更新数据的部分. 局部更新数据实现的途径就是通过虚拟DOM, 局部更新数据最重要就是ReactJS的Diff算法. 同时引入组件化的开发思想从另一个角度构建Web前端页面. 在ReactJS构建的应用程序中, 可以将整个页面视为一个由许多子组件构成的大组件, 这样最明显的好处就是增加代码的可用性, 一个组件可以在多个UI界面中使用.</p><p>Diff算法基于两种假设:</p><ul><li>不同类型组件产生不同DOM结构</li><li>对于同一层次的一组子组件, 可以通过唯一的id进行区分</li></ul><p>ReactJS组件应具备的三个特征:</p><ul><li>可组合: 能够和其它组件一起使用</li><li>可维护: 每个组件只包含自己内部的逻辑代码, 更容易维护</li><li>可测试: 测试单个组件内部的逻辑代码相比较于测试整个UI代码更加容易</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReactJS是Facebook开发的UI库, 这个库有助于创建交互式, 基于状态和可重用的UI库. ReactJS已经用于Facebook自己的Instagram项目. ReactJS不仅可以运行在客户端, 也可以用于服务器端, 从而使客户端和服务器端协同操作.&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="ReactJS" scheme="https://yieeo.github.io/tags/ReactJS/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6</title>
    <link href="https://yieeo.github.io/2018/05/06/JavaScript-ES6/"/>
    <id>https://yieeo.github.io/2018/05/06/JavaScript-ES6/</id>
    <published>2018-05-06T03:59:53.000Z</published>
    <updated>2018-12-04T15:07:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript6.0(简称ES6)是JavaScript语言的下一代标准, 已经在2015年6月正式发布了. 它的目标是使JavaScript可以用来编写复杂的大型应用程序, 成为企业级开发语言. 各个浏览器对ECMAScript6的支持可以查看 <a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es6/</a>.</p><h4 id="Babel转码器"><a href="#Babel转码器" class="headerlink" title="Babel转码器"></a>Babel转码器</h4><p><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>是一个广泛的ECMAScript6转码器, 可以将ECMAScript6代码转为ECMAScript5代码. 通过这种方式就不用担心当前环境是否支持ECMAScript6.</p><p>Babel提供了一个<a href="https://babeljs.io/repl/" target="_blank" rel="noopener">REPL在线编译器</a>, 可以在线将ECMAScript6代码转为ECMAScript5代码.</p><p>Babel还提供了<code>Babel-cli</code>工具, 可以使用命令行转码.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm是node.js包管理工具,使用npm命令必须先安装node.js</span></span><br><span class="line"><span class="comment"># 使用npm命令安装babel-cli工具</span></span><br><span class="line">$ npm i -g babel-cli</span><br></pre></td></tr></table></figure><p>基本用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转码结果输出到标准输出</span></span><br><span class="line">$ babel example.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码结果写入一个文件中</span></span><br><span class="line"><span class="comment"># -o(也可以使用--out-file参数)参数指定输出文件</span></span><br><span class="line">$ babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个目录转码</span></span><br><span class="line"><span class="comment"># -d参数(也可以使用--out-dir参数)指定输出目录</span></span><br><span class="line">$ babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s参数生成source map文件</span></span><br><span class="line">$ babel src -d lib -s</span><br></pre></td></tr></table></figure><h4 id="let和const关键字"><a href="#let和const关键字" class="headerlink" title="let和const关键字"></a>let和const关键字</h4><p>ECMAScript6新增了let关键字, 用来声明变量. 它的用法与var关键字类似, 但是用let关键字声明的变量, 只在let关键字所在的代码块内有效, 不会和var关键字一样发生变量提升.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>ECMAScript6明确规定, 区块中存在let和const关键字, 这个区块对这些声明的变量和常量, 从一开始就形成了封闭作用域. 只要在声明之前使用这些变量和常量, 就会报错.</p><p>在代码块中, 使用let关键字声明变量之前, 该变量是不可用的, 这在语法上称为<code>TDZ</code>(暂时性死区).</p><p>let关键字不允许在相同作用域中重复声明同一变量, let关键字为JavaScript新增了块级作用域, ECMAScript6引入了块级作用域, 明确允许在块级作用域中声明函数.</p><p>const关键字用来声明一个只读常量, 声明过后, 常量的值就不能改变. const关键字声明的常量也是不提升的, 也存在<code>TDZ</code>, 只能在声明之后使用常量.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于复合类型的常量, 常量名不指向数据, 而是指向数据所在的地址. const关键字只保证变量名指向地址不变, 并不保证该地址的数据不变.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  bar: <span class="string">'zero'</span>,</span><br><span class="line">  bingo: <span class="string">'four'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bingo = <span class="string">'two'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bingo); <span class="comment">// two</span></span><br></pre></td></tr></table></figure><blockquote><p>ECMAScript6规定var关键字和function关键字声明的全局变量, 依旧是全局对象的属性; let关键字, const关键字和class关键字声明的全局变量和常量, 不属于全局对象的属性</p></blockquote><h4 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [foo, [[bar], bingo]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(bingo); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构数组允许指定默认值</span></span><br><span class="line">[foo, bar = <span class="number">1</span>] = [<span class="number">3</span>]; <span class="comment">// foo = 3, bar = 1</span></span><br><span class="line">[foo, bar = <span class="number">1</span>] = [<span class="number">3</span>, <span class="literal">undefined</span>]; <span class="comment">// foo = 3, bar = 1</span></span><br></pre></td></tr></table></figure><blockquote><p>ECMAScript6内部使用严格相等相等符(===)判断一个值. 如果一个数组成员不严格等于undefined,默认值不会生效.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的解构赋值</span></span><br><span class="line"><span class="keyword">var</span> &#123; bar, foo &#125; = &#123; <span class="attr">bar</span>: <span class="string">'one'</span>, <span class="attr">foo</span>: <span class="string">'two'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// one</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// two</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">bar</span>: bingo &#125; = &#123; <span class="attr">bar</span>: <span class="string">'one'</span>, <span class="attr">foo</span>: <span class="string">'two'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bingo); <span class="comment">// one</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// error: bar is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>对象的解构与数组有一些不同. 数组的元素是按次序排序的, 变量的取值由它的位置决定, 而对象的属性没有次序, 变量必须与属性同名, 才能取得正确值.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数的解构赋值</span></span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>], [<span class="number">7</span>, <span class="number">2</span>]].map(<span class="function"><span class="keyword">function</span>(<span class="params">[a, b]</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;); <span class="comment">// [6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的解构赋值用作:</span></span><br><span class="line"><span class="comment">// 交换变量的值</span></span><br><span class="line"><span class="comment">// 提交JSON的值</span></span><br><span class="line"><span class="comment">// 函数参数的默认值</span></span><br></pre></td></tr></table></figure><h4 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// includes(): 返回布尔值, 表示是否找到参数字符串</span></span><br><span class="line"><span class="comment">// startWidth(): 返回布尔值, 表示参数字符串是否在源字符串的头部</span></span><br><span class="line"><span class="comment">// endsWidth(): 返回布尔值, 表示参数字符是否在源字符串的尾部</span></span><br><span class="line"><span class="comment">// 第二个参数n, endsWidth()方法与另两个方法不同, 它针对前n个字符</span></span><br><span class="line"><span class="comment">// 另两个方法第二个参数n针对从第n个位置直到字符串结束</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="string">'hello world!'</span>;</span><br><span class="line">bar.startWidth(<span class="string">'world'</span>, <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line">bar.endsWidth(<span class="string">'hello'</span>, <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line">bar.includes(<span class="string">'hello'</span>, <span class="number">6</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// repeat()方法返回一个新字符串, 表示将源字符串重复n次</span></span><br><span class="line"><span class="comment">// 'bingo'.repeat(2); // 'bingobingo'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// padStart()方法用于头部补全</span></span><br><span class="line"><span class="comment">// padEnd()方法用于尾部补全</span></span><br><span class="line"><span class="comment">// 第一个参数用来指定字符串的最小长度</span></span><br><span class="line"><span class="comment">// 第二个参数用来补全的字符串</span></span><br><span class="line"><span class="string">'go'</span>.padStart(<span class="number">5</span>, <span class="string">'a'</span>); <span class="comment">// 'aaago'</span></span><br><span class="line"><span class="string">'go'</span>.padStart(<span class="number">4</span>, <span class="string">'abc'</span>); <span class="comment">// 'abgo'</span></span><br><span class="line"><span class="string">'go'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>); <span class="comment">// 'goaba'</span></span><br><span class="line"><span class="string">'go'</span>.padEnd(<span class="number">3</span>,<span class="string">'abcd'</span>); <span class="comment">// 'goa'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板字符串是增强版的字符串, 用反引号标识. 它可以当作普通字符串使用</span></span><br><span class="line"><span class="comment">// 也可以用来定义多行字符串或者字符串嵌入变量</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'Mike'</span>, time = <span class="string">'today'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span>); <span class="comment">// Hello Mike, how are you today?</span></span><br></pre></td></tr></table></figure><h4 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h4><blockquote><p>在ECMAScript5开始, 严格模式中八进制不再允许使用前缀<code>0</code>表示, 要使用前缀<code>0o</code>表示</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number.isFinite()方法: 检查一个数字是否无穷(infinity)</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.0008</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number.isNaN()方法: 检查一个值是否为NaN(not a number)</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">10</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>它们与传统的全局方法isFinite()和isNaN()的区别, 传统方法先调用Number将非数值的值转为数值, 在进行判断, 这两个新方法只对数值有效, 非数值一律返回false.</p><p>Number.parseInt(), Number.parseFloat():<br>ECMAScript6将全局方法parseInt()和parseFloat()移植到了Number对象上, 作用完全保持不变.</p><p>Number.isInteger():<br>用来判断一个值是否为整数, 在JavaScript内部, 整数和浮点数是同样的存储方法, 4和4.0被视为同一个值.</p><p>安全整数和Number.isSafeInteger():<br>JavaScript能准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间(不含两个端点), 超过范围, 无法精确表示.</p><p>ECMAScript6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>两个常量, 用来表示这个范围的上下限.<br>Number.isSafeInteger()方法用来判断一个整数是否在这个范围内.</p><p>Math对象的扩展</p><ul><li>Math.trunc()方法用于去除一个数的小数部分, 返回整数部分.</li><li>Math.sign()方法用来判断一个数是正数, 负数还是零.</li><li>Math.cbrt()方法用来计算一个数的立方根.</li><li>Math.fround()方法返回一个数的单精度浮点数形式.</li><li>Math.hypot方法返回所有参数的平方和的平方根.</li></ul><h4 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.from()方法用于将两类对象转为真正的数组:</span></span><br><span class="line"><span class="comment">// 类似数组的对象(array-like object)和可遍历(iterable)的对象(包括新增的数据结构Set和Map)</span></span><br><span class="line"><span class="comment">// 常见的类似数组的对象是DOM操作返回的NodeList集合, 以及函数内部的arguments对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(foo).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">let</span> bingo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.of()方法: 将一组值,转为数组形式</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>); <span class="comment">// [1, 5, 8]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实例的copyWithin()方法</span></span><br><span class="line"><span class="comment">// Array.prototype.copyWithin(target, start = 0, end = this.length)</span></span><br><span class="line"><span class="comment">// 第一个参数target(必需): 从该位置开始替换数据</span></span><br><span class="line"><span class="comment">// 第二个参数start(可选): 从该位置开始读取数据,默认为0.如果为负数,表示倒数</span></span><br><span class="line"><span class="comment">// 第三个参数end(可选): 到该位置停止读取数据,默认等于数组长度.如果为负数,表示倒数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实例的find()方法: 找出第一个符合条件的数组元素</span></span><br><span class="line"><span class="comment">// 参数为一个回调函数, 所有数组元素依次执行该回调函数, 直到找到第一个返回值为true的元素, 返回该元素</span></span><br><span class="line"><span class="comment">// 没有符合条件的元素, 返回undefined</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">-8</span>, <span class="number">6</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// -8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组实例的findIndex()方法用法与find()方法类似</span></span><br><span class="line"><span class="comment">// 不过返回的是第一个符合条件的数组元素的索引, 没有符合田间的元素,返回-1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">-8</span>, <span class="number">6</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fill()方法使用给定值, 填充一个数组</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>].fill(<span class="number">4</span>); <span class="comment">// [4, 4, 4]</span></span><br></pre></td></tr></table></figure><p>ECMAScript6提供三个新方法–entries(), key()和values(), 用于遍历数组. 唯一区别是key()方法是对键名的遍历, values()方法是对键值的遍历,entries()方法是对键值对的遍历.</p><h4 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="comment">// ECMAScript6允许使用"箭头"( =&gt; )定义函数</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="params">a</span> =&gt;</span> a;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数注意点:</p><ul><li>函数体内的this对象, 就是定义时所在的对象, 而不是使用时所在的对象</li><li>不可以当作构造函数, 不可以使用new关键字创建实例对象, 否则抛出一个错误</li><li>不可以使用arguments对象, 该对象在函数体中不存在. 如要使用Rest参数代替</li><li>不可以使用yield关键字, 箭头函数不能用作Generator函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMAScript6允许给函数的参数设置默认值</span></span><br><span class="line"><span class="comment">// 函数参数的默认值直接写在参数定义的后面</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="string">'one'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定默认之后, 函数的length属性可以返回没有指定默认值的参数个数</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">1</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">2</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ECMAScript6引入rest参数(形式为'...变量名')</span></span><br><span class="line"><span class="comment">// 用于获取函数的剩余参数</span></span><br><span class="line"><span class="comment">// rest参数搭配的变量是一个数组, 该变量将剩余的参数放入数组中</span></span><br><span class="line"><span class="comment">// rest参数之后不能再有参数, 否则报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展运算符(spread)是三个点( ... )</span></span><br><span class="line"><span class="comment">// 它好比rest参数的逆运算, 将一个数组转为用逗号分隔的参数序列</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>); <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"><span class="comment">// ECMAScript5写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// ECMAScript6写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用扩展运算符合并数组</span></span><br><span class="line"><span class="keyword">var</span> arrOne = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arrTwo = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"><span class="keyword">var</span> arrThree = [<span class="string">'f'</span>];</span><br><span class="line"><span class="comment">// ECMAScript5写法</span></span><br><span class="line">arrOne.concat(arrTwo, arrThree); <span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class="line"><span class="comment">// ECMAScript6写法</span></span><br><span class="line">[...arrOne, ...arrTwo, ...arrThree] <span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用扩展字符串将字符串转为数组</span></span><br><span class="line">[...<span class="string">'bingo'</span>] <span class="comment">// ['b', 'i', 'n', 'g', 'o']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Iterator接口的对象</span></span><br><span class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.getElementById(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">var</span> arr = [...nodeList];</span><br></pre></td></tr></table></figure><h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMAScript6允许在对象中, 可以不写属性值</span></span><br><span class="line"><span class="comment">// 这时属性值等于属性名所代表的变量</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Mary'</span>,</span><br><span class="line">  <span class="comment">// 等同于birthday: birthday</span></span><br><span class="line">  birthday,</span><br><span class="line">  <span class="comment">// 等同于say: function () ...</span></span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.assign()方法用于对象的合并</span></span><br><span class="line"><span class="comment">// 将源对象(source)的所有可枚举属性, 复制到目标对象(target)</span></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> sourceOne = &#123; <span class="attr">b</span>: <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> sourceTwo = &#123; <span class="attr">c</span>: <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, sourceOne, sourceTwo);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123; a: 1, b: 9, c: 6 &#125;</span></span><br></pre></td></tr></table></figure><p>如果目标对象与源对象有同名属性, 或多个源对象有同名属性, 则后面的属性会覆盖前面的属性. Object.assign()方法实现的是浅拷贝, 而不是深拷贝. 如果源对象某个属性值是对象, 那目标杜希昂拷贝得到的是这个对象的引用.</p><p>Object.assign()方法的用处:</p><ul><li>为对象添加属性</li><li>为对象添加方法</li><li>克隆对象</li><li>合并多个对象</li><li>为属性指定默认值</li></ul><p>ECMAScript6属性的遍历方法:</p><ul><li>for..in循环遍历对象自身和继承的可枚举属性(不含Symbol属性)</li><li>Object.keys(obj)方法返回一个数组, 包含对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)</li><li>Object.getOwnPropertyNames(obj)方法返回一个数组, 包含对象自身的所有属性(包含不可枚举属性, 不含Symbol属性)</li><li>Object.getOwnPropertySymbols(obj)方法返回一个数组, 包含对象自身的所有Symbol属性</li><li>Reflect.ownKeys(obj)方法返回一个数组, 包含对象自身的所有属性, 不管是属性名是Symbol或字符串, 也不管是否可枚举</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMAScript5对象属性名都是字符串, 容易造成属性名的冲突</span></span><br><span class="line"><span class="comment">// 为了防止属性名的冲突, ECMAScript6引入了Symbol</span></span><br><span class="line"><span class="comment">// Symbol值作为对象属性名时, 不能用点运算符</span></span><br><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> bar = &#123;&#125;;</span><br><span class="line">bar.mySymbol = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar[mySymbol]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(bar[<span class="string">'mySymbol'</span>]); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>点运算符后面总是字符串, 所以不会读取mySymbol作为标识符所指代的那个值, 导致bar的属性名实际上是一个字符串, 而不是一个Symbol的值.</p><p>Symbol作为属性名, 该属性不出现在for..in, for..of循环中, 也不会被Object.keys()方法和Object.getOwnPropertyNames()方法返回. 但是他也不是私有属性, Object.getOwnPropertySymbols()方法可以获取指定对象的所有Symbol属性名.</p><p>Reflect.ownKeys()方法可以返回所有类型的键名, 包括常规键名和Symbol键名.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'obj_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">  foo: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj); <span class="comment">// [Symbol(obj_key), 'bar', 'foo']</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol.for()方法可以重新使用同一个Symbol的值</span></span><br><span class="line"><span class="comment">// 它接收一个字符串作为参数, 搜索有没有以该参数作为名称的Symbol值</span></span><br><span class="line"><span class="comment">// 如果搜索有这个值, 返回这个Symbol值</span></span><br><span class="line"><span class="comment">// 否则就新建并返回一个以该字符串为名称的Symbol值</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> symOne = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(symOne); <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">var</span> symTwo = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(symTwo); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h4><p>ECMAScript6提供了新的数据结构Set. 它类似数组, 但元素值都是唯一的, 无重复值. Set本身是一个构造函数, 可以用来生成Set数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>].map(<span class="function"><span class="params">a</span> =&gt;</span> bar.add(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> bar) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 2 5 6 1</span></span><br></pre></td></tr></table></figure><p>Set实例对象的属性和方法</p><ul><li>Set.prototype.constructor属性: 构造函数, 默认是Set函数</li><li>Set.prototype.size属性: 返回Set实例对象的成员总数</li><li>add(value)方法: 添加某个值, 返回Set结构本身</li><li>delete(value)方法: 删除某个值, 返回一个布尔值, 表示删除是否成功</li><li>has(value)方法: 返回一个布尔值, 表示该值是否为Set的成员</li><li>clear()方法: 清除所有成员, 没有返回值</li></ul><p>JavaScript对象本质上是键值对的集合(Hash结构), 传统上只能用字符串当作键, 给使用带来了限制. 为了解决这个问题, ECMAScript6提供了Map数据结构, 它类似对象, 也是键值对的集合, 但是”键”的范围不限于字符串, 各种类型的值(包括对象)都可以当作键.</p><p>原生Map提供三个遍历器生成函数和一个遍历方法</p><ul><li>keys(): 返回键名的遍历器</li><li>values(): 返回键值的遍历器</li><li>entries(): 返回所有成员的遍历器</li><li>forEach(): 遍历Map的所有成员</li></ul><h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>Generator函数从语法上可以把它理解成是一个状态机, 封装了多个内部状态. 执行Generator函数会返回一个遍历器对象, 他除了状态机, 还是一个遍历器对象生成函数, 返回的遍历器对象, 可以一次遍历Generator函数内部的每一个状态.</p><p>Generator函数形式上是一个普通函数, 但有两个特点, function关键字与函数名之间有一个星号, 函数体内部使用yield语句定义不同的内部状态.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Gener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = Gener();</span><br><span class="line">foo.next(); <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">foo.next(); <span class="comment">// &#123; value: 'world', done: fasle &#125;</span></span><br><span class="line">foo.next(); <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">foo.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h4 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* success */</span>) &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise实例对象可以使用then()方法分别指定Resolved状态和Reject状态的回调函数. then()方法可以接收两个回调函数作为参数. 第一个回调函数是Promise对象的状态变为Resolved时调用, 第二个回调函数是Promise对象的状态变为Reject时调用. 第二个回调函数是可选的, 不一定要提供, 这两个回调函数都可以接收Promise对象传出的值作为参数. then()方法返回的是一个新的Promise实例(不是原来的Promise实例), 我们可以使用链式写法, 即then()方法之后再调用另一个then()方法.</p><p>Promise实例对象的catch()方法, 也就是<code>.then(null, rejection)</code>的别名, 用于指定发生错误时的回调函数. 不要在then()方法里面定义Reject状态的回调函数(即then()方法的第二个参数), 而是使用catch()方法.</p><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.a + <span class="string">', '</span> + <span class="keyword">this</span>.b + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了一个”类”, 里面有一个constructor()方法, 这就是构造函数, this关键字代表实例对象. 由于类的方法默认定义在prototype对象上面, 所以类的新方法可以添加在prototype对象上面. Object.assign()方法可以很方便一次向类添加多个方法.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Person.prototype, &#123;</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>类内部所有定义的方法都是不可枚举的(non-enumerable).</p></blockquote><p>constructor()方法是类的默认方法, 通过new关键字创建实例对象时, 自动调用该方法. 一个类必须有constructor()方法, 如果没有显示定义, 会默认添加一个空的constructor()方法. contructor()方法默认返回的实例对象(即this)可以指定返回另一个对象.</p><h4 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class之间可以使用extends关键字实现继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类构造函数中, 只有调用super()方法之后, 才可以使用this关键字, 否则会报错</span></span><br><span class="line"><span class="comment">// Class不存在变量提升</span></span><br><span class="line"><span class="keyword">new</span> Person(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Object.getPrototypeOf()方法可以从子类上获取父类, 可以使用该方法判断一个类是否继承至另一个类</p></blockquote><p>super关键字</p><ul><li>作为函数调用时(即super(…args)), super代表父类的构造函数</li><li>作为对象调用时(即super.prop或者super.method()), super代表父类, 此时super既可以引用父类实例的属性和方法, 也可以引用父类的静态方法</li></ul><p>Class静态方法</p><p>类相当于实例的原型, 所有在类中定义的方法, 都会被实例继承. 在一个方法前加上static关键字, 表示该方法不会被实例继承, 而是直接通过类来调用, 这被称为<code>静态方法</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ECMAScript6.0(简称ES6)是JavaScript语言的下一代标准, 已经在2015年6月正式发布了. 它的目标是使JavaScript可以用来编写复杂的大型应用程序, 成为企业级开发语言. 各个浏览器对ECMAScript6的支持可以查看 &lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>OOP in JavaScript</title>
    <link href="https://yieeo.github.io/2018/04/10/JavaScript-OOP/"/>
    <id>https://yieeo.github.io/2018/04/10/JavaScript-OOP/</id>
    <published>2018-04-10T09:44:54.000Z</published>
    <updated>2018-12-04T15:07:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>对象和类是面向对象的基础, 封装, 继承和多态是面向对象编程(OOP)的三大特性.</p><p>JavaScript提供了对象却缺乏类, 他不能和Java等语言一样显式的定义一个类. 但是JavaScript函数功能非常灵活, 我们可以使用构造函数和原型对象来实现类.</p><h4 id="对象和类的概念"><a href="#对象和类的概念" class="headerlink" title="对象和类的概念"></a>对象和类的概念</h4><p><code>对象</code>是面向对象编程中非常重要的一个概念, 一个对象是一个<code>东西</code>(某个人或者某件事)的描述.<br>对象包含特征和行为, 用OOP的术语来说, 特征是对象的属性, 行为是对象的方法.</p><p><code>类</code>相当于一个模板, 基于这个模板可以创建不同的具体对象.</p><blockquote><p>在JavaScript中一切都是基于对象的, <code>原型</code>也是对象, JavaScript的继承和重用也是通过原型实现的.</p></blockquote><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>我们可以使用<code>new Array()</code>创建一个数组, 使用<code>new Object()</code>创建一个对象. <code>Array()</code>和<code>Object()</code>是JavaScript内置的两个构造函数, 尽管JavaScript没有提供类, 我们可以将Array和Object理解为”类”的概念.</p><p>构造函数也是函数, 定义构造函数和其它函数并没有语法上的区别. 唯一的区别就是构造函数的首字母应该大写, 这也是JavaScript的编程规范.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Person()构造函数, 我们可以将它理解为Person类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为Person类添加属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Mary'</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">this</span>.sex = <span class="string">'male'</span>;</span><br><span class="line">  <span class="comment">// 为Person类添加方法</span></span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'believe in youself'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Person()构造函数创建实例对象</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><blockquote><p>foo实例对象和bar实例对象都是通过Person构造函数创建出来的, 但是修改其中一个的实例对象的属性和方法并不会影响的另一个实例对象的属性和方法.</p></blockquote><h4 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h4><p>当创建一个对象时, 一个特殊的属性就被JavaScript自动分配给这个对象了, 这个属性就是constructor属性. 当访问某个对象的constructor属性时, 就会返回创建这个对象的构造函数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Mary'</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">this</span>.sex = <span class="string">'male'</span>;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'believe in youself'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bingo = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(bingo.constructor); <span class="comment">// 返回构造函数Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.constructor); <span class="comment">// 返回内置的构造函数Object</span></span><br></pre></td></tr></table></figure><h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h4><p>在JavaScript中定义一个函数, 这个函数就会拥有prototype属性, 构造函数也不例外.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Mary'</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">this</span>.sex = <span class="string">'male'</span>;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'believe in youself'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(bingo.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>构造函数Person的prototype属性是一个对象, 他是属于函数的, 我们称这个属性为原型对象. 从Person类的角度出发, 可以理解为prototype属性是属于Person类的. 同时Person类的实例对象是没有prototype属性的, 上面代码中的<code>bingo.prototype</code>是<code>undefined</code>, 说明prototype属性是共享的.</p></blockquote><p>既然实例对象的prototype属性是一个对象, 那么我们就可以给这个对象添加属性和方法.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'believe in youself'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构造函数Person的prototype属性上添加属性和方法</span></span><br><span class="line"><span class="comment">// 在Person.prototype属性上定义的属性和方法可以直接被Person类的实例对象使用</span></span><br><span class="line">Person.prototype.hobby = <span class="string">'swim'</span>;</span><br><span class="line">Person.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'is run in the park'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person(<span class="string">'Mary'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.run());</span><br></pre></td></tr></table></figure><blockquote><p>我们可以通过<code>hasOwnPrototype</code>方法查看对象是否包含某个属性或方法.</p></blockquote><h4 id="类的实现总结"><a href="#类的实现总结" class="headerlink" title="类的实现总结"></a>类的实现总结</h4><ul><li>JavaScript没有类,但是构造函数可以实现<code>类</code></li><li>按照JavaScript编程规范,构造函数的首字母应该大写</li><li>在创建对象时,JavaScript为这个对象分配了一个<code>constructor</code>属性,<code>constructor</code>属性是对象构造函数的引用</li><li>函数在定义时拥有了<code>prototype</code>属性,<code>prototype</code>属性也是一个对象</li><li>prototype属性上的属性和方法是共享的,定义在<code>prototype</code>属性的属性和方法可以被”类”的实例对象使用</li><li>如果属性或者方法能够定义在<code>prototype</code>属性上,就不要定义在构造函数中,使用<code>prototype</code>可以减少内存开销</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象和类是面向对象的基础, 封装, 继承和多态是面向对象编程(OOP)的三大特性.&lt;/p&gt;
&lt;p&gt;JavaScript提供了对象却缺乏类, 他不能和Java等语言一样显式的定义一个类. 但是JavaScript函数功能非常灵活, 我们可以使用构造函数和原型对象来实现类.&lt;/
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript RegExp Object</title>
    <link href="https://yieeo.github.io/2018/03/21/JavaScript-RegExp/"/>
    <id>https://yieeo.github.io/2018/03/21/JavaScript-RegExp/</id>
    <published>2018-03-21T06:33:28.000Z</published>
    <updated>2018-12-04T15:07:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="创建正则对象"><a href="#创建正则对象" class="headerlink" title="创建正则对象"></a>创建正则对象</h4><p>构建函数RegExp创建正则对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = new RegExp(&apos;i$&apos;); // reg匹配以i字母结尾的字符串</span><br></pre></td></tr></table></figure><p>使用正则字面量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /i$/;</span><br></pre></td></tr></table></figure><h4 id="正则表达式字符"><a href="#正则表达式字符" class="headerlink" title="正则表达式字符"></a>正则表达式字符</h4><p>反斜杠<code>\</code>在正则表达式中表示转义序列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">特殊符号:</span><br><span class="line">^ $ . * + ? = ! | \ / ( ) [ ] &#123; &#125;</span><br></pre></td></tr></table></figure><p>如果要在正则表达式中匹配特殊符号, 就应该在特殊符号前面的加上反斜杠<code>\</code>进行转义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\$/; // reg匹配$符号</span><br></pre></td></tr></table></figure><p>字面量字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------ </span><br><span class="line">    字符   |   匹配                                               </span><br><span class="line">------------------------------------------------------------------ </span><br><span class="line">   \o      |   NUL字符(\u0000)                                   </span><br><span class="line">   \t      |   制表符(\u0009)                                    </span><br><span class="line">   \n      |   换行符(\u000A)                                    </span><br><span class="line">   \v      |   垂直制表符(\u000B)                                </span><br><span class="line">   \f      |   换页符                                            </span><br><span class="line">   \r      |   回车符                                            </span><br><span class="line">   \xnn    |   十六进制数nn指定拉丁字符, 如: \x0A等同于\n         </span><br><span class="line">   \uxxxx  |   十六进制xxxx指定的Unicode字符, 如: \u0009等同于\t  </span><br><span class="line">------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span><br><span class="line">     字符         |    匹配</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">  [...]           |    中括号内的任意字符</span><br><span class="line">  [^...]          |    非中括号内的任意字符</span><br><span class="line">  [0-9]           |    0-9之间的数字</span><br><span class="line">  [a-z]           |    小写拉丁字母</span><br><span class="line">  [A-Z]           |    大写拉丁字母</span><br><span class="line">  [ 0-9a-zA-Z ]   |    数字和大小写拉丁字母</span><br><span class="line">  .               |    除换行符和其它Unicode行终止符之外的任意字符</span><br><span class="line">  \s              |    任意Unicode空白符</span><br><span class="line">  \S              |    任意非Unicode空白符</span><br><span class="line">  \d              |    任意ASCII码数字, 等同于[0-9]</span><br><span class="line">  \D              |    任意非ASCII码数字字符, 等同于[^0-9]</span><br><span class="line">  \w              |    等同于[a-zA-Z0-9_]</span><br><span class="line">  \W              |    等同于[^a-zA-Z0-9_]</span><br><span class="line">------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>贪婪的重复字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span><br><span class="line">      字符        |     匹配次数</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">      &#123;n,m&#125;       |     至少n次, 但不能超过m次</span><br><span class="line">      &#123;n,&#125;        |     至少n次</span><br><span class="line">      &#123;n&#125;         |     刚好n次</span><br><span class="line">      ?           |     零次或者一次, 等同于&#123;0,1&#125;</span><br><span class="line">      +           |     至少一次, 等同于&#123;1,&#125;</span><br><span class="line">      *           |     零次或者多次, 等同于&#123;0,&#125;</span><br><span class="line">------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>非贪婪的重复匹配只需要在贪婪的重复字符后面加上一个<code>?</code>, 且问好之后没有其它的表达式字符, 不然会忽略非贪婪匹配</p><p>选择,分组和引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">  字符        |  含义</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">  |           | 表示或,用于分隔选择</span><br><span class="line">  ()          | 子表达式(子模式), 引用子模式匹配结果</span><br><span class="line">  (?:)        | 子表达式(子模式), 引用子模式匹配结果, 匹配结果不显示在正则匹配结果中</span><br><span class="line">  \n(n为数字)  | 引用对应的子模式匹配结果</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>位置字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">  字符   |  含义</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">  ^      |  字符串的开头</span><br><span class="line">  $      |  字符串的结尾</span><br><span class="line">  \b     |  位于\w和\W的边界或者位于一个ASCII单词字符与一个字符串开头和结尾之间的边界</span><br><span class="line">  \B     |  非词语之间的位置</span><br><span class="line">  (?=p)  |  正前向声明, 要求接下来的字符与模式p匹配,但不包括匹配中的字符</span><br><span class="line">  (?!p)  |  反前向声明, 要求接下来的字符不与模式p匹配</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="正则对象标志-属性和方法"><a href="#正则对象标志-属性和方法" class="headerlink" title="正则对象标志, 属性和方法"></a>正则对象标志, 属性和方法</h4><p>标志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------</span><br><span class="line">         标志          |        含义</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">         g             |        全局匹配</span><br><span class="line">         i             |        不区分大小写</span><br><span class="line">         m             |        多行匹配</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------</span><br><span class="line">  方法    |   含义</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">  exec    |   接收一个字符串参数, 返回由完全匹配和子表达式匹配结果组成的数组</span><br><span class="line">  test    |   接收一个字符串参数, 返回boolean值</span><br><span class="line">  compile |   编译正则表达式</span><br><span class="line">-------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------</span><br><span class="line">  属性       |    含义</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">  sourse     |    正则表达式的文本</span><br><span class="line">  global     |    是否拥有全局搜索标志g</span><br><span class="line">  ignoreCase |    是否拥有标志i</span><br><span class="line">  multiline  |    是否拥有标志m</span><br><span class="line">  lastIndex  |    搜索匹配的开始位置(可读写)</span><br><span class="line">-------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;创建正则对象&quot;&gt;&lt;a href=&quot;#创建正则对象&quot; class=&quot;headerlink&quot; title=&quot;创建正则对象&quot;&gt;&lt;/a&gt;创建正则对象&lt;/h4&gt;&lt;p&gt;构建函数RegExp创建正则对象&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Function Closures</title>
    <link href="https://yieeo.github.io/2018/02/18/JavaScript-closures/"/>
    <id>https://yieeo.github.io/2018/02/18/JavaScript-closures/</id>
    <published>2018-02-18T10:15:32.000Z</published>
    <updated>2018-12-04T15:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方对闭包的解释: 一个拥有许多变量和绑定这些变量的环境的表达式(通常是一个函数)</p></blockquote><h4 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h4><ul><li>作为一个函数变量的一个引用, 当函数返回时, 其处于激活状态</li><li>一个闭包就是当一个函数返回时, 一个没有释放资源的栈区</li></ul><p>简单理解,JavaScript允许使用内部函数, 即函数定义和函数表达式位于另一个函数的函数体内. 而且, 这些内部函数可以访问它们所在的外部函数中声明的所有局部变量和参数以及声明的其它内部函数. 当其中一个这样的内部函数在包含它们的外部函数被调用时, 就会形成闭包.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'the power of imagination makes us infinite'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = closure();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上述代码, 变量bar定义在函数closure中, 属于局部变量. 若变量bar在closure函数调用完成以后不能再被访问, 在函数执行完成后变量bar将被释放. 但是由于函数closure返回一个内部函数, 而且返回函数引用了变量bar, 导致了变量bar可能会在closure函数执行完成以后还会被引用, 所以变量bar占用的资源不会回收, 这时函数closure就形成一个闭包.</p><blockquote><p>JavaScript垃圾回收(GC)的原则是: 如果一个对象不再被引用,那么这个对象会被垃圾回收器回收. 如果两个对象无干扰的互相引用, 那么则两个对象也会被回收.</p></blockquote><h4 id="为执行的函数提供参数"><a href="#为执行的函数提供参数" class="headerlink" title="为执行的函数提供参数"></a>为执行的函数提供参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeout()方法可以延迟执行某个函数</span></span><br><span class="line"><span class="comment">// 第一个参数是需要执行的函数或者代码</span></span><br><span class="line"><span class="comment">// 第二个参数是延迟的毫秒数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'life is not lack of beauty, just missing a pair of eyes to find beauty'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(say(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在setTimeout方法中我们无法给需要的延迟执行的函数传递参数</span></span><br><span class="line"><span class="comment">// 使用闭包我们这样做</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(say(<span class="string">'there is no end to learning'</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h4 id="模拟静态私有变量"><a href="#模拟静态私有变量" class="headerlink" title="模拟静态私有变量"></a>模拟静态私有变量</h4><blockquote><p>JavaScript本身不支持面向对象(OOP)的特性. 但是我们可以通过JavaScript的一些特性模拟实现JavaScript面向对象.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类, 模拟静态私有变量</span></span><br><span class="line"><span class="keyword">var</span> ClassPerson = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>; <span class="comment">// 静态私有变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getA()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(bingo.getA()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在上面的例子中, 使用变量a记录ClassPerson被实例化的次数, 使用闭包将变量a模拟为静态私有变量, 每次ClassPerson被实例化时将变量a的值加一. 定义在外层函数内或者内层函数外的成员类似静态成员. 这种形式的代码称作<code>静态封装环境</code>.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方对闭包的解释: 一个拥有许多变量和绑定这些变量的环境的表达式(通常是一个函数)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;闭包的特点&quot;&gt;&lt;a href=&quot;#闭包的特点&quot; class=&quot;headerlink&quot; title=&quot;闭包的特点&quot;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript this Keyword</title>
    <link href="https://yieeo.github.io/2018/01/19/JavaScript-this/"/>
    <id>https://yieeo.github.io/2018/01/19/JavaScript-this/</id>
    <published>2018-01-19T12:56:14.000Z</published>
    <updated>2018-12-04T15:06:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在执行上下文的创建阶段, 会分别生成变量对象, 建立作用域链, 确定this指向. this指向是在函数被调用的时候确定的, 也就是执行上下文被创建时确定的. 一个函数中的this指向可以非常灵活.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 4</span></span><br><span class="line">foo.call(obj); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><blockquote><p>在函数执行过程中, this一旦被确定, 就不可更改.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span> = obj; <span class="comment">// 试图修改this, 运行时会报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h4 id="全局对象中的this"><a href="#全局对象中的this" class="headerlink" title="全局对象中的this"></a>全局对象中的this</h4><blockquote><p>全局对象对象中的this, 指向它本身.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过this绑定到全局对象</span></span><br><span class="line"><span class="keyword">this</span>.a = <span class="string">'zero'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过声明绑定到变量对象, 全局环境中变量对象就是它本身</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'one'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值操作, 标识符会隐式绑定到全局对象</span></span><br><span class="line">c = <span class="string">'two'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印日志</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure><h4 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the first demo</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the second demo</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the third demo</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">50</span>,</span><br><span class="line">  b: <span class="keyword">this</span>.a + <span class="number">10</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b);</span><br><span class="line"><span class="built_in">console</span>.log(obj.foo());</span><br></pre></td></tr></table></figure><p>想要准确确定this指向, 找到函数的调用者以及区分它是否独立调用就变得十分关键. 在一个函数上下文中, this由调用者提供, 由调用函数的方式来决定. 如果调用者函数被某一个对象所拥有, 那么该函数在调用时, 内部的this指向该对象, 如果函数独立调用, 那么该函数内部的this, 则指向undefined. 但在非严格模式中, this指向undefined时, 它会被自动指向全局对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式this会自动指向全局, 我们在函数内部使用严格模式获得更准确的判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// bar是调用者, 独立调用</span></span><br><span class="line"><span class="built_in">window</span>.bar(); <span class="comment">// bar是调用者, 被window对象所拥有</span></span><br></pre></td></tr></table></figure><p>在上面的例子中, <code>bar()</code>作为独立调用者, 按照定义的理解, 它内部的this指向<code>undefined</code>. 而<code>window.bar()</code>因为fn()方法被window对象所拥有, 内部的this指向window对象.</p><p>在<code>the third demo</code>中, 对象obj的b属性使用<code>this.a + 10</code>来计算. 单独的<code>{}</code>不会形成新的作用域的, 因此这里的<code>this.a</code>, 由于没有作用域的限制, 它仍处于全局作用域中, 所以这里的this其实指向的是window对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bar()); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = foo.bar();</span><br><span class="line"><span class="built_in">console</span>.log(bingo()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><code>foo.bar()</code>中, bar是调用者, 它不是独立调用, 被对象foo所拥有, 因此它的this指向foo. 而<code>bingo()</code>作为调用者, 尽管它与foo.bar的引用相同, 但是它是独立调用的, 因此this指向undefined, 在非严格模式中, 自动指向window全局对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稍微修改一下代码</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: bar</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bar()); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次修改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bingo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn(); <span class="comment">// 独立调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bingo(obj.bar); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h4 id="call-apply显式指定this指向"><a href="#call-apply显式指定this指向" class="headerlink" title="call,apply显式指定this指向"></a>call,apply显式指定this指向</h4><p>JavaScript内部给我们提供两种方法<code>call()</code>和<code>apply()</code>, 可以手动设置this的指向. 所有函数都具有这两个方法, 除了参数略有不同, 实现功能完全一样.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// bar并不是obj的方法, 通过call方法, 将bar内部的this指向obj对象</span></span><br><span class="line"><span class="comment">// 通过this.a访问obj的a属性</span></span><br><span class="line">bar.call(obj); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.c + a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// call()方法和apply()方法的参数:</span></span><br><span class="line"><span class="comment">// 第一个参数为this将要指向的对象</span></span><br><span class="line"><span class="comment">// 第二个参数call()方法是以单个的方式传递, apply()是以数组的方式传递</span></span><br><span class="line">bar.call(obj, <span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 18</span></span><br><span class="line">bar.apply(obj,[<span class="number">10</span>,<span class="number">5</span>]); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将类数组对象转换为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 使用call/apply将arguments转为数组, 返回数组, arguments不会改变</span></span><br><span class="line">  <span class="keyword">var</span> arg = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;</span><br><span class="line">example(<span class="string">'zero'</span>,<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改this指向</span></span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  name: <span class="string">'joker'</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'say hello world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">'knight'</span></span><br><span class="line">&#125;;</span><br><span class="line">bar.say.call(foo);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.sex = [<span class="string">'male,female'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Son = <span class="function"><span class="keyword">function</span> (<span class="params">name, age, hobby</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">  <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype.message = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'name: '</span> + <span class="keyword">this</span>.name + <span class="string">', age: '</span> + <span class="keyword">this</span>.age + <span class="string">', sex: '</span> + <span class="keyword">this</span>.sex + <span class="string">', hobby: '</span> + <span class="keyword">this</span>.hobby);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Son(<span class="string">'Mike'</span>, <span class="number">18</span>, <span class="string">'swim'</span>).message();</span><br></pre></td></tr></table></figure><p>在Son构造函数中使用call()方法将父级构造函数执行了一次, 相当于将Person中的代码在Son构造函数复制了一份, this指向为Son构造函数new出来的实例对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Son = <span class="function"><span class="keyword">function</span> (<span class="params">name, age, hobby</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.sex = [<span class="string">'male'</span>,<span class="string">'female'</span>];</span><br><span class="line">  <span class="comment">// Person.call(this, name, age); 相当于执行了上面三行代码</span></span><br><span class="line">  <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在向其它执行上下文的传递中, 确保this指向保持不变</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们希望bar()方法被obj对象调用时, this指向obj对象</span></span><br><span class="line"><span class="comment">// 但是匿名函数导致this指向丢失, 在匿名函数中this指向了全局</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(fucntion () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改上面代码</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将this的引用保存起来, 赋值给that变量</span></span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    setTimeout(fucntion () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that.a);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.bar();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装bind()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(bind(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;, <span class="keyword">this</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ES5中的bind()方法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构造函数与原型方法上的this"><a href="#构造函数与原型方法上的this" class="headerlink" title="构造函数与原型方法上的this"></a>构造函数与原型方法上的this</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">40</span>);</span><br><span class="line">bingo.foo();</span><br></pre></td></tr></table></figure><p>new操作符调用构造函数会经历是个阶段:</p><ul><li>创建一个新对象</li><li>构造函数的this指向这个新对象</li><li>指向构造函数的代码, 为这个对象添加属性和方法</li><li>返回新对象</li></ul><p>new操作符调用构造函数, this指向这个新建的对象, 然后将新对象返回, 被实例对象<code>bingo</code>接收.</p><p>原型方法上的this, 根据上面例子函数中的this定义, <code>bingo.foo()</code>中的foo为调用者, 它被bingo对象所拥有, foo中的this指向bingo对象.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在执行上下文的创建阶段, 会分别生成变量对象, 建立作用域链, 确定this指向. this指向是在函数被调用的时候确定的, 也就是执行上下文被创建时确定的. 一个函数中的this指向可以非常灵活.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Scope</title>
    <link href="https://yieeo.github.io/2018/01/08/JavaScript-scope/"/>
    <id>https://yieeo.github.io/2018/01/08/JavaScript-scope/</id>
    <published>2018-01-08T05:26:14.000Z</published>
    <updated>2018-12-04T15:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作用域是一套用于确定在何处以及如何查找变量的规则. 赋值操作会导致LHS查询, 获取变量值的操作会导致RHS查询. 引擎在处理代码时会优化处理变量声明和函数声明, 这种机制叫做提升.</p></blockquote><h4 id="JavaScript编译原理"><a href="#JavaScript编译原理" class="headerlink" title="JavaScript编译原理"></a>JavaScript编译原理</h4><p>在传统的编译语言流程中, 程序的执行会经过三个步骤, 我们称这个过程为编译</p><ul><li>分词: 词法分析(将字符串分解成有意义的代码块)</li><li>解析: 语法分析(将词法单元转换成一个由元素逐级嵌套代表的程序语法结构的树)</li><li>代码生成(将上面生成的树转换为可执行的代码)</li></ul><p>JavaScript是属于解释性语言, 但是代码的编译过程与上面类似, 现在浏览器执行JavaScript代码非常快速, 一般编译过程发生在代码运行前的一瞬间.</p><h4 id="scope-作用域"><a href="#scope-作用域" class="headerlink" title="scope(作用域)"></a>scope(作用域)</h4><p>作用域负责收集和维护由所有变量组成的查询, 并且确定一套规则来判断当前代码对这些变量的访问权限.</p><p>对于<code>var foo = 0;</code>来说, 编译器首先在当前作用域声明一个变量foo, 之后在运行时JS引擎会从当前作用域中查找变量foo, 再然后将数字0赋值给变量foo.</p><h4 id="scope-chain-作用域链"><a href="#scope-chain-作用域链" class="headerlink" title="scope chain(作用域链)"></a>scope chain(作用域链)</h4><p>每一个函数都有自己的执行环境, 当函数嵌套在另一个函数或块中, 就会形成作用域链. 作用域链的前端就是当前执行环境, 全局执行环境的变量即作用域链的顶端. 在当前作用域中找不到变量时, JS引擎会沿着作用域链一级一级向上查询, 直到找到为止.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>上面的例子中, foo的作用域中没有变量a, 需要使用变量a需要向上一级查找.</p><h4 id="LHS-and-RHS"><a href="#LHS-and-RHS" class="headerlink" title="LHS and RHS"></a>LHS and RHS</h4><p>JS引擎进行变量查询的方式有两种, 分别是LHS和RHS. LHS表示查询赋值操作的目标, RHS表示查询赋值操作的源头. 简单的说, LHS查询是寻找这个变量的容器本身, 从而进行赋值操作, RHS查询是查找某个变量的值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>对上面的例子进行分析:</p><ul><li>要执行函数foo, 需要知道其赋值操作的源头, 从而进行RHS引用</li><li>接下来把数字1赋值给函数foo的形参a, 需要进行一次LHS引用, 这是一个隐式变量分配</li><li>对console进行RHS引用, console是一个内置对象, 有log()方法</li><li>确认形参a的值, 进行一次RHS查询, 将形参a的值传递给console对象的log()方法</li></ul><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>如果RHS查询在所有的作用域链都没有找到所需的变量时, JS引擎就会抛出ReferenceError异常. 如果RHS查询到目标变量, 但尝试进行非法操作时, JS引擎会抛出TypeError异常.</p><p>如果LHS查询在所有的作用域链中都找不到所需的变量时, 就会在全局作用域中创建该变量并返还给JS引擎.</p><blockquote><p>注意: 严格模式中禁止自动或隐式创建变量,LHS查询失败时同样会返回ReferenceError异常.</p></blockquote><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p>作用域一般有两种工作模式, 一种是为大多数语言使用的词法作用域, 另一种是动态作用域.</p><p>词法作用域就是定义在词法阶段的作用域. 词法作用域是由书写代码是函数声明位置决定的. 作用域一旦确定基本上会保持不变. 当然也有欺骗词法的方法, 但不推荐使用, 欺骗作用域会导致性能下降.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域, 只有foo标识符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">m</span>) </span>&#123; <span class="comment">// foo的作用域, m, n和bar三个标识符</span></span><br><span class="line">  <span class="keyword">var</span> n = m - <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123; <span class="comment">// bar的作用域, 只有x标识符</span></span><br><span class="line">    <span class="built_in">console</span>.log(m, n, x);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(n + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="欺骗词法-eval"><a href="#欺骗词法-eval" class="headerlink" title="欺骗词法-eval"></a>欺骗词法-eval</h4><p>eval()方法会接收一个字符串作为参数, 并将字符串视作代码片段进行执行.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">str,a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="string">'var b = 4'</span>, <span class="number">2</span>); <span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure><blockquote><p>严格模式下, eval()方法创建的变量不能被调用.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">str, a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="string">'var b = 4'</span>, <span class="number">2</span>); <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>使用eval()方法生成代码将造成性能上的损失, 不推荐使用.</p></blockquote><h4 id="欺骗词法-with"><a href="#欺骗词法-with" class="headerlink" title="欺骗词法-with"></a>欺骗词法-with</h4><p>with()方法会将一个对象的引用当作作用域来处理, 将对象的属性当作作用域的标识符来处理, 从而创建一个新的作用域. 这种方法也会使JS引擎在编译时无法对作用域进行优化, 从而造成性能上的损失.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'one'</span>,</span><br><span class="line">  b: <span class="string">'two'</span>,</span><br><span class="line">  c: <span class="string">'three'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">  a = <span class="string">'four'</span>,</span><br><span class="line">  b = <span class="string">'five'</span>,</span><br><span class="line">  c = <span class="string">'seven'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>严格模式中with()方法被完全禁止.</p></blockquote><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><blockquote><p>属于这个函数的全部变量可以在整个函数内部或其嵌套的作用域内部使用, 这即是函数的作用域.</p></blockquote><p>1.隐藏内部实现</p><p>函数作用域可以将声明在该函数内部的变量或函数隐藏起来, 从而实现良好的设计模式. 在模块和对象的API设计中, 这种方法很常见也很实用.</p><p>下面是利用对象全局命名空间来规避冲突的方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameSpace = &#123;</span><br><span class="line">  doSomeThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  doAnotherThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.立即执行函数表达式(IIFE)</p><p>我们希望函数不需要函数名或者函数名不会污染所在的作用域, 并且能够自动执行. 这是我们可以使用IIFE来实现.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  a: <span class="string">'zero'</span>,</span><br><span class="line">  b: <span class="string">'one'</span>,</span><br><span class="line">  c: <span class="string">'two'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">global</span>) </span>&#123; <span class="comment">// 将bar对象的引用传递进去, 参数命名为global</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'three'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// three</span></span><br><span class="line">  <span class="built_in">console</span>.log(global.a); <span class="comment">// zero</span></span><br><span class="line">&#125;)(bar);</span><br></pre></td></tr></table></figure><h4 id="块作用域-try-catch"><a href="#块作用域-try-catch" class="headerlink" title="块作用域(try..catch)"></a>块作用域(try..catch)</h4><p>ES3中规定try..catch会创建一个块级作用域, 其中声明的变量仅在catch内部有效.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 正常执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(err); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><h4 id="块作用域-let"><a href="#块作用域-let" class="headerlink" title="块作用域-let"></a>块作用域-let</h4><p>ES6中引用了let关键字, 可以将变量绑定到任意的作用域中. let将其声明的变量隐式的放到了它所在的块作用域中.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 正常执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用&#123;..&#125;显式声明变量</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><h4 id="块作用域-const"><a href="#块作用域-const" class="headerlink" title="块作用域-const"></a>块作用域-const</h4><p>ES6中引入了const关键字, 用来声明常量. 同样可以用来创建块作用域.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">9</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><blockquote><p>声明在这个作用域中的变量都将作用在这个作用域中.</p></blockquote><h4 id="函数和变量提升"><a href="#函数和变量提升" class="headerlink" title="函数和变量提升"></a>函数和变量提升</h4><p>作用域中的声明将在代码本身执行之前首先处理, 将这个过程想象成所用声明(变量和函数)都会被移动到各自作用域的前端, 这个过程称为提升.</p><blockquote><p>先有声明后有赋值.只有函数和变量会进行提升</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码, 编译器会把声明var a; 提升到全局顶部首先进行处理, 即按照如下顺序处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有声明本身会被提升, 赋值和其它逻辑语句会停留在原地</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器把var a = 0; 视为两部分, 即var a;和a = 0;</span></span><br><span class="line"><span class="comment">// 将var a;提升到全局顶部, 首先进行处理, 赋值操作a = 0; 留在原地.</span></span><br><span class="line"><span class="comment">// 编译器会按照如下形式处理这段代码:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个作用域只会在自己的作用域范围内进行提升</span></span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码块中, 全局作用域中的函数声明会被提升, bar函数作用域中的var a;也会被提升</span></span><br><span class="line"><span class="comment">// 即按照下面的顺序进行处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><blockquote><p>函数首先会被提升, 然后才是变量. 要避免重复声明, 当变量声明和函数声明混合在一起容易造成混乱.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作用域是一套用于确定在何处以及如何查找变量的规则. 赋值操作会导致LHS查询, 获取变量值的操作会导致RHS查询. 引擎在处理代码时会优化处理变量声明和函数声明, 这种机制叫做提升.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;JavaSc
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>The History Of JavaScript</title>
    <link href="https://yieeo.github.io/2017/11/21/JavaScript-history/"/>
    <id>https://yieeo.github.io/2017/11/21/JavaScript-history/</id>
    <published>2017-11-20T23:53:54.000Z</published>
    <updated>2018-12-04T15:07:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是由Netscape Communications Corporation(网景公司)程序员Brendan Eich(布兰登.艾克)于1995年创造出来的. Eich只用了10天就开发出了这门脚本语言, 最初命名为Mocha.</p><p>1995年9月网景公司在自己的Netscape Navigator浏览器2.0中将这门语言改名为LiveScript. 同年12月, 网景公司为了将这门语言搭上Java这个编程语言”热词”, 随后又改名为JavaScript, 但是这门语言与Java没有任何关系. 随后JavaScript在浏览器上大获成功, 不久后微软公司在自己的Internet Explorer浏览器上推出了JScript, 与网景公司进行同台竞争. JScript也是一种JavaScript的实现, 这两个的语言版本的共存使得浏览器的语言标准化的缺失. 微软在自己的网页技术上加入一些的自己的专属方法, 使得网页在不同的浏览器的效果呈现出的不同的效果, 程序员写一份代码无法在不同的浏览器上呈现出相同的效果, 对于相应的浏览器必须写兼容相应浏览器的代码. 语言实现的不同专有化DOM(文档对象模型)的差异, 成为了网络上普及JavaScript的阻碍.</p><p>终于在1996年11月, 网景公司正式向ECMA(欧洲计算机制造商协会)提交语言标准. 1997年6月, ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262.ECMA标准. 流程以循环方式运行 - ECMAScript 2于1998年发布, ECMAScript 3于1999年发布(演变为今天的现代JavaScript). 尽管微软开始用JScript语言实现一些提议, 但很明显微软不会在Internet Explorer中实现JavaScript. 2005年, Eich和Mozilla加入ECMA协助E4X(ECMA-357), 与Macromedia(被Adobe收购)合作, 他们正致力于在ActionScript 3中实施E4X. 这种合作的目标是标准化AS3中的内容并在SpiderMonkey中实现它. 因此, Adobe发布了Tamarin, 一个源自AVM2的开放课程项目.</p><p>开源社区和开发者社区也在努力彻底改变JavaScript以及可以用它做些什么, 社区的影响达到了顶峰, Jesse James Garrett于2005年发布了一篇论文, 其中描述了JavaScript支持的一组技术作为支柱. 他创造了“Ajax”这个词. 该文引发了大量开发人员倾向于JavaScript以及围绕它的开源社区和库. 此外, jQuery, Prototype和Dojo是新发布的库之一. Ajax的优势使JavaScript成为人们关注的焦点, 并带来了更多专业的编程注意力. 结果是全面的框架和库的增加, 以及在Web浏览器之外增加JavaScript的使用, 正如服务器端JavaScript平台的激增.</p><p>截至2016年, 统计数据显示, 约92％的网站使用JavaScript - 其中包括一些全球最大的网站, 如Google和Facebook. 并且由于JavaScript, 使这些网站成为现实的元素是可能的. 例如, 如果没有JavaScript, 我们就不会拥有我们习以为常的实时通知. 今天, JavaScript仍然无处不在 - 它是最常用的客户端脚本语言. JavaScript被写入HTML文档, 并以许多独特的方式实现与网页的交互. 例如, 由于JavaScript, 我们可以自动安排约会和玩在线游戏. 此外, 诸如Node.js之类的新开发允许在服务器端使用JavaScript, 而诸如HTML5之类的API允许控制用户媒体和其他设备功能.</p><h4 id="JavaScript的组成部分"><a href="#JavaScript的组成部分" class="headerlink" title="JavaScript的组成部分"></a>JavaScript的组成部分</h4><ul><li>ECMAScript, 描述了该语言的语法和基本对象</li><li>DOM(文档对象模型), 描述了处理网页内容的方法和接口</li><li>BOM(浏览器对象模型), 描述了与浏览器进行交互的方法和接口</li></ul><h4 id="JavaScript的基本特点"><a href="#JavaScript的基本特点" class="headerlink" title="JavaScript的基本特点"></a>JavaScript的基本特点</h4><p>JavaScript通常缩写为JS, 是一种高级的, 解释执行的编程语言. JavaScript是一门基于原型和函数先行的语言, 是一门多范式的语言, 它支持面向对象编程, 命令式编程, 以及函数式编程. 随着最新的HTML5和CSS3语言标准的推行它还可以用于游戏, 桌面和移动应用程序的开发和在服务器端网络环境运行, 如Node.js</p><p>JavaScript由ECMA通过ECMAScript实现语言的标准化, 已经被世界上绝大多数浏览器所使用, 也被世界上的主流浏览器(Chrome, FireFox, Opera, Safari, IE)支持.</p><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>既然谈到了浏览器, 就不得不谈谈现在的主流浏览器的内核, 浏览器内核可以分为两部分: 渲染引擎和JS引擎. 最开始渲染引擎和JS引擎并没有区分的很明确, 后来JS引擎(最著名的JS引擎就是Google的V8引擎, V8引擎也促进了后来Node.js的诞生)越来越独立, 内核倾向于只指渲染引擎.</p><ul><li>Chrome浏览器内核: 统称为Chromium内核或Chrome内核, 以前是Webkit内核, 现在是Blink内核</li><li>FireFox浏览器内核: Gecko内核</li><li>Opera浏览器内核: 最初是自己的Presto内核, 后与Google一起研发内核, 使用过Webkit内核, 现在是Blink内核</li><li>Safari浏览器内核: Webkit内核</li><li>IE浏览器内核: Trident内核</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript是由Netscape Communications Corporation(网景公司)程序员Brendan Eich(布兰登.艾克)于1995年创造出来的. Eich只用了10天就开发出了这门脚本语言, 最初命名为Mocha.&lt;/p&gt;
&lt;p&gt;1995年9
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
