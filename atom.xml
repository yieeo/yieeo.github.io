<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yie&#39;s Blog</title>
  
  <subtitle>The power of imagination makes us infinite,Welcome to yie&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yieeo.github.io/"/>
  <updated>2018-10-21T07:46:48.085Z</updated>
  <id>https://yieeo.github.io/</id>
  
  <author>
    <name>yie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript RegExp Object</title>
    <link href="https://yieeo.github.io/2018/03/21/JavaScript-RegExp/"/>
    <id>https://yieeo.github.io/2018/03/21/JavaScript-RegExp/</id>
    <published>2018-03-21T06:33:28.000Z</published>
    <updated>2018-10-21T07:46:48.085Z</updated>
    
    <content type="html"><![CDATA[<h4 id="创建正则对象"><a href="#创建正则对象" class="headerlink" title="创建正则对象"></a>创建正则对象</h4><p>构建函数RegExp创建正则对象</p><blockquote><p>var reg = new RegExp(‘i$’); // reg匹配以i字母结尾的字符串</p></blockquote><p>使用正则字面量</p><blockquote><p>var reg = /i$/;</p></blockquote><h4 id="正则表达式字符"><a href="#正则表达式字符" class="headerlink" title="正则表达式字符"></a>正则表达式字符</h4><p>反斜杠<code>\</code>在正则表达式中表示转义序列</p><blockquote><p>特殊符号:</p></blockquote><blockquote><p>^ $ . * + ? = ! | \ / ( ) [ ] { }</p></blockquote><p>如果要在正则表达式中匹配特殊符号,就应该在特殊符号前面的加上反斜杠<code>\</code>进行转义</p><blockquote><p>var reg = /\$/; // reg匹配$符号</p></blockquote><p>字面量字符</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">匹配</th></tr></thead><tbody><tr><td style="text-align:left">\o</td><td style="text-align:left">NUL字符(\u0000)</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">制表符(\u0009)</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">换行符(\u000A)</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">垂直制表符(\u000B)</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">换页符</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车符</td></tr><tr><td style="text-align:left">\xnn</td><td style="text-align:left">十六进制数nn指定拉丁字符,如: \x0A等同于\n</td></tr><tr><td style="text-align:left">\uxxxx</td><td style="text-align:left">十六进制xxxx指定的Unicode字符,如: \u0009等同于\t</td></tr></tbody></table><p>字符</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">匹配</th></tr></thead><tbody><tr><td style="text-align:left">[…]</td><td style="text-align:left">中括号内的任意字符</td></tr><tr><td style="text-align:left">[^…]</td><td style="text-align:left">非中括号内的任意字符</td></tr><tr><td style="text-align:left">[0-9]</td><td style="text-align:left">0-9之间的数字</td></tr><tr><td style="text-align:left">[a-z]</td><td style="text-align:left">小写拉丁字母</td></tr><tr><td style="text-align:left">[A-Z]</td><td style="text-align:left">大写拉丁字母</td></tr><tr><td style="text-align:left">[ 0-9a-zA-Z ]</td><td style="text-align:left">数字和大小写拉丁字母</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">除换行符和其它Unicode行终止符之外的任意字符</td></tr><tr><td style="text-align:left">\s</td><td style="text-align:left">任意Unicode空白符</td></tr><tr><td style="text-align:left">\S</td><td style="text-align:left">任意非Unicode空白符</td></tr><tr><td style="text-align:left">\d</td><td style="text-align:left">任意ASCII码数字,等同于[0-9]</td></tr><tr><td style="text-align:left">\D</td><td style="text-align:left">任意非ASCII码数字字符,等同于[^0-9]</td></tr><tr><td style="text-align:left">\w</td><td style="text-align:left">等同于[a-zA-Z0-9_]</td></tr><tr><td style="text-align:left">\W</td><td style="text-align:left">等同于[^a-zA-Z0-9_]</td></tr></tbody></table><p>贪婪的重复字符</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">匹配</th></tr></thead><tbody><tr><td style="text-align:left">{n,m}</td><td style="text-align:left">至少n次,但不能超过m次</td></tr><tr><td style="text-align:left">{n,}</td><td style="text-align:left">至少n次</td></tr><tr><td style="text-align:left">{n}</td><td style="text-align:left">刚好n次</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">零次或者一次,等同于{0,1}</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">至少一次,等同于{1,}</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">零次或者多次,等同于{0,}</td></tr></tbody></table><p>非贪婪的重复匹配只需要在贪婪的重复字符后面加上一个<code>?</code>,且问好之后没有其它的表达式字符,不然会忽略非贪婪匹配</p><p>选择,分组和引用</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">\</td><td style="text-align:left"></td><td>表示或,用于分隔选择</td></tr><tr><td style="text-align:left">()</td><td style="text-align:left">子表达式(子模式),引用子模式匹配结果</td></tr><tr><td style="text-align:left">(?:)</td><td style="text-align:left">子表达式(子模式),引用子模式匹配结果,匹配结果不显示在正则匹配结果中</td></tr><tr><td style="text-align:left">\n(n为数字)</td><td style="text-align:left">引用对应的子模式匹配结果</td></tr></tbody></table><p>位置字符</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">匹配</th></tr></thead><tbody><tr><td style="text-align:left">^</td><td style="text-align:left">字符串的开头</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">字符串的结尾</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">位于\w和\W的边界或者位于一个ASCII单词字符与一个字符串开头和结尾之间的边界</td></tr><tr><td style="text-align:left">\B</td><td style="text-align:left">非词语之间的位置</td></tr><tr><td style="text-align:left">(?=p)</td><td style="text-align:left">正前向声明,要求接下来的字符与模式p匹配,但不包括匹配中的字符</td></tr><tr><td style="text-align:left">(?!p)</td><td style="text-align:left">反前向声明,要求接下来的字符不与模式p匹配</td></tr></tbody></table><h4 id="正则对象标志-属性和方法"><a href="#正则对象标志-属性和方法" class="headerlink" title="正则对象标志,属性和方法"></a>正则对象标志,属性和方法</h4><p>标志</p><table><thead><tr><th style="text-align:left">标志</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">g</td><td style="text-align:left">全局匹配</td></tr><tr><td style="text-align:left">i</td><td style="text-align:left">不区分大小写</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">多行匹配</td></tr></tbody></table><p>方法</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">exec</td><td style="text-align:left">接收一个字符串参数,返回由完全匹配和子表达式匹配结果组成的数组</td></tr><tr><td style="text-align:left">test</td><td style="text-align:left">接收一个字符串参数,返回boolean值</td></tr><tr><td style="text-align:left">compile</td><td style="text-align:left">编译正则表达式</td></tr></tbody></table><p>属性</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">sourse</td><td style="text-align:left">正则表达式的文本</td></tr><tr><td style="text-align:left">global</td><td style="text-align:left">是否拥有全局搜索标志g</td></tr><tr><td style="text-align:left">ignoreCase</td><td style="text-align:left">是否拥有标志i</td></tr><tr><td style="text-align:left">multiline</td><td style="text-align:left">是否拥有标志m</td></tr><tr><td style="text-align:left">lastIndex</td><td style="text-align:left">搜索匹配的开始位置(可读写)</td></tr></tbody></table><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;创建正则对象&quot;&gt;&lt;a href=&quot;#创建正则对象&quot; class=&quot;headerlink&quot; title=&quot;创建正则对象&quot;&gt;&lt;/a&gt;创建正则对象&lt;/h4&gt;&lt;p&gt;构建函数RegExp创建正则对象&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;var reg = new Reg
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript Function Closures</title>
    <link href="https://yieeo.github.io/2018/02/18/JavaScript-closures/"/>
    <id>https://yieeo.github.io/2018/02/18/JavaScript-closures/</id>
    <published>2018-02-18T10:15:32.000Z</published>
    <updated>2018-10-20T06:52:40.993Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方对闭包的解释: 一个拥有许多变量和绑定这些变量的环境的表达式(通常是一个函数)</p></blockquote><h4 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h4><ul><li>作为一个函数变量的一个引用,当函数返回时,其处于激活状态</li><li>一个闭包就是当一个函数返回时,一个没有释放资源的栈区</li></ul><p>简单理解,JavaScript允许使用内部函数,即函数定义和函数表达式位于另一个函数的函数体内.而且,这些内部函数可以访问它们所在的外部函数中声明的所有局部变量和参数以及声明的其它内部函数.当其中一个这样的内部函数在包含它们的外部函数被调用时,就会形成闭包.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'the power of imagination makes us infinite'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = closure();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上述代码,变量bar定义在函数closure中,属于局部变量.若变量bar在closure函数调用完成以后不能再被访问,在函数执行完成后变量bar将被释放.但是由于函数closure返回一个内部函数,而且返回函数引用了变量bar,导致了变量bar可能会在closure函数执行完成以后还会被引用,所以变量bar占用的资源不会回收,这时函数closure就形成一个闭包.</p><blockquote><p>JavaScript垃圾回收(GC)的原则是: 如果一个对象不再被引用,那么这个对象会被垃圾回收器回收.如果两个对象无干扰的互相引用,那么则两个对象也会被回收.</p></blockquote><h4 id="为执行的函数提供参数"><a href="#为执行的函数提供参数" class="headerlink" title="为执行的函数提供参数"></a>为执行的函数提供参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeout()方法可以延迟执行某个函数</span></span><br><span class="line"><span class="comment">// 第一个参数是需要执行的函数或者代码</span></span><br><span class="line"><span class="comment">// 第二个参数是延迟的毫秒数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'life is not lack of beauty, just missing a pair of</span></span><br><span class="line"><span class="string">   eyes to find beauty'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(say(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在setTimeout方法中我们无法给需要的延迟执行的函数传递参数</span></span><br><span class="line"><span class="comment">// 使用闭包我们这样做</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(say(<span class="string">'there is no end to learning'</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h4 id="模拟静态私有变量"><a href="#模拟静态私有变量" class="headerlink" title="模拟静态私有变量"></a>模拟静态私有变量</h4><blockquote><p>JavaScript本身不支持面向对象(OOP)的特性.但是我们可以通过JavaScript的一些特性模拟实现JavaScript面向对象.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类,模拟静态私有变量</span></span><br><span class="line"><span class="keyword">var</span> ClassPerson = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>; <span class="comment">// 静态私有变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getA()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(bingo.getA()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在上面的例子中,使用变量a记录ClassPerson被实例化的次数,使用闭包将变量a模拟为静态私有变量,每次ClassPerson被实例化时将变量a的值加一.定义在外层函数内或者内层函数外的成员类似静态成员.这种形式的代码称作<code>静态封装环境</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方对闭包的解释: 一个拥有许多变量和绑定这些变量的环境的表达式(通常是一个函数)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;闭包的特点&quot;&gt;&lt;a href=&quot;#闭包的特点&quot; class=&quot;headerlink&quot; title=&quot;闭包的特点&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript this Keyword</title>
    <link href="https://yieeo.github.io/2018/01/19/JavaScript-this/"/>
    <id>https://yieeo.github.io/2018/01/19/JavaScript-this/</id>
    <published>2018-01-19T12:56:14.000Z</published>
    <updated>2018-10-20T01:22:54.526Z</updated>
    
    <content type="html"><![CDATA[<p>在执行上下文的创建阶段,会分别生成变量对象,建立作用域链,确定this指向.this指向是在函数被调用的时候确定的,也就是执行上下文被创建时确定的.一个函数中的this指向可以非常灵活.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 4</span></span><br><span class="line">foo.call(obj); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><blockquote><p>在函数执行过程中,this一旦被确定,就不可更改.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span> = obj; <span class="comment">// 试图修改this,运行时会报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h4 id="全局对象中的this"><a href="#全局对象中的this" class="headerlink" title="全局对象中的this"></a>全局对象中的this</h4><blockquote><p>全局对象对象中的this,指向它本身.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过this绑定到全局对象</span></span><br><span class="line"><span class="keyword">this</span>.a = <span class="string">'zero'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过声明绑定到变量对象,全局环境中变量对象就是它本身</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'one'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值操作,标识符会隐式绑定到全局对象</span></span><br><span class="line">c = <span class="string">'two'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印日志</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure><h4 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the first demo</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the second demo</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the third demo</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">50</span>,</span><br><span class="line">  b: <span class="keyword">this</span>.a + <span class="number">10</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b);</span><br><span class="line"><span class="built_in">console</span>.log(obj.foo());</span><br></pre></td></tr></table></figure><p>想要准确确定this指向,找到函数的调用者以及区分它是否独立调用就变得十分关键.在一个函数上下文中,this由调用者提供,由调用函数的方式来决定.如果调用者函数被某一个对象所拥有,那么该函数在调用时,内部的this指向该对象,如果函数独立调用,那么该函数内部的this,则指向undefined.但在非严格模式中,this指向undefined时,它会被自动指向全局对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式this会自动指向全局,我们在函数内部使用严格模式获得更准确的判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// bar是调用者,独立调用</span></span><br><span class="line"><span class="built_in">window</span>.bar(); <span class="comment">// bar是调用者,被window对象所拥有</span></span><br></pre></td></tr></table></figure><p>在上面的例子中,<code>bar()</code>作为独立调用者,按照定义的理解,它内部的this指向<code>undefined</code>.而<code>window.bar()</code>因为fn()方法被window对象所拥有,内部的this指向window对象.</p><p>在<code>the third demo</code>中,对象obj的b属性使用<code>this.a + 10</code>来计算.单独的<code>{}</code>不会形成新的作用域的,因此这里的<code>this.a</code>,由于没有作用域的限制,它仍处于全局作用域中,所以这里的this其实指向的是window对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bar()); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = foo.bar();</span><br><span class="line"><span class="built_in">console</span>.log(bingo()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><code>foo.bar()</code>中,bar是调用者,它不是独立调用,被对象foo所拥有,因此它的this指向foo.而<code>bingo()</code>作为调用者,尽管它与foo.bar的引用相同,但是它是独立调用的,因此this指向undefined,在非严格模式中,自动指向window全局对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稍微修改一下代码</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: bar</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bar()); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次修改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bingo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn(); <span class="comment">// 独立调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bingo(obj.bar); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h4 id="call-apply显式指定this指向"><a href="#call-apply显式指定this指向" class="headerlink" title="call,apply显式指定this指向"></a>call,apply显式指定this指向</h4><p>JavaScript内部给我们提供两种方法<code>call()</code>和<code>apply()</code>,可以手动设置this的指向.所有函数都具有这两个方法,除了参数略有不同,实现功能完全一样.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// bar并不是obj的方法,通过call方法,将bar内部的this指向obj对象</span></span><br><span class="line"><span class="comment">// 通过this.a访问obj的a属性</span></span><br><span class="line">bar.call(obj); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.c + a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// call()方法和apply()方法的参数:</span></span><br><span class="line"><span class="comment">// 第一个参数为this将要指向的对象</span></span><br><span class="line"><span class="comment">// 第二个参数call()方法是以单个的方式传递,apply()是以数组的方式传递</span></span><br><span class="line">bar.call(obj, <span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 18</span></span><br><span class="line">bar.apply(obj,[<span class="number">10</span>,<span class="number">5</span>]); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将类数组对象转换为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 使用call/apply将arguments转为数组,返回数组,arguments不会改变</span></span><br><span class="line">  <span class="keyword">var</span> arg = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;</span><br><span class="line">example(<span class="string">'zero'</span>,<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改this指向</span></span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  name: <span class="string">'joker'</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'say hello world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">'knight'</span></span><br><span class="line">&#125;;</span><br><span class="line">bar.say.call(foo);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.sex = [<span class="string">'male,female'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Son = <span class="function"><span class="keyword">function</span> (<span class="params">name, age, hobby</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">  <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype.message = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'name: '</span> + <span class="keyword">this</span>.name + <span class="string">', age: '</span> + <span class="keyword">this</span>.age + <span class="string">', sex: '</span></span><br><span class="line">   + <span class="keyword">this</span>.sex + <span class="string">', hobby: '</span> + <span class="keyword">this</span>.hobby);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Son(<span class="string">'Mike'</span>, <span class="number">18</span>, <span class="string">'swim'</span>).message();</span><br></pre></td></tr></table></figure><p>在Son构造函数中使用call()方法将父级构造函数执行了一次,相当于将Person中的代码在Son构造函数复制了一份,this指向为Son构造函数new出来的实例对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Son = <span class="function"><span class="keyword">function</span> (<span class="params">name, age, hobby</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.sex = [<span class="string">'male'</span>,<span class="string">'female'</span>];</span><br><span class="line">  <span class="comment">// Person.call(this, name, age); 相当于执行了上面三行代码</span></span><br><span class="line">  <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在向其它执行上下文的传递中,确保this指向保持不变</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们希望bar()方法被obj对象调用时,this指向obj对象</span></span><br><span class="line"><span class="comment">// 但是匿名函数导致this指向丢失,在匿名函数中this指向了全局</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(fucntion () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改上面代码</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将this的引用保存起来,赋值给that变量</span></span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    setTimeout(fucntion () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that.a);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.bar();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装bind()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(bind(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;, <span class="keyword">this</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ES5中的bind()方法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构造函数与原型方法上的this"><a href="#构造函数与原型方法上的this" class="headerlink" title="构造函数与原型方法上的this"></a>构造函数与原型方法上的this</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">40</span>);</span><br><span class="line">bingo.foo();</span><br></pre></td></tr></table></figure><p>new操作符调用构造函数会经历是个阶段:</p><ul><li>创建一个新对象</li><li>构造函数的this指向这个新对象</li><li>指向构造函数的代码,为这个对象添加属性和方法</li><li>返回新对象</li></ul><p>new操作符调用构造函数,this指向这个新建的对象,然后将新对象返回,被实例对象<code>bingo</code>接收.</p><p>原型方法上的this,根据上面例子函数中的this定义,<code>bingo.foo()</code>中的foo为调用者,它被bingo对象所拥有,foo中的this指向bingo对象.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在执行上下文的创建阶段,会分别生成变量对象,建立作用域链,确定this指向.this指向是在函数被调用的时候确定的,也就是执行上下文被创建时确定的.一个函数中的this指向可以非常灵活.&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript Scope</title>
    <link href="https://yieeo.github.io/2018/01/08/JavaScript-scope/"/>
    <id>https://yieeo.github.io/2018/01/08/JavaScript-scope/</id>
    <published>2018-01-08T05:26:14.000Z</published>
    <updated>2018-10-20T01:36:52.776Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作用域是一套用于确定在何处以及如何查找变量的规则.赋值操作会导致LHS查询,获取变量值的操作会导致RHS查询.引擎在处理代码时会优化处理变量声明和函数声明,这种机制叫做提升.</p></blockquote><h4 id="JavaScript编译原理"><a href="#JavaScript编译原理" class="headerlink" title="JavaScript编译原理"></a>JavaScript编译原理</h4><p>在传统的编译语言流程中,程序的执行会经过三个步骤,我们称这个过程为编译</p><ul><li>分词: 词法分析(将字符串分解成有意义的代码块)</li><li>解析: 语法分析(将词法单元转换成一个由元素逐级嵌套代表的程序语法结构的树)</li><li>代码生成(将上面生成的树转换为可执行的代码)</li></ul><p>JavaScript是属于解释性语言,但是代码的编译过程与上面类似,现在浏览器执行JavaScript代码非常快速,一般编译过程发生在代码运行前的一瞬间.</p><h4 id="scope-作用域"><a href="#scope-作用域" class="headerlink" title="scope(作用域)"></a>scope(作用域)</h4><p>作用域负责收集和维护由所有变量组成的查询,并且确定一套规则来判断当前代码对这些变量的访问权限.</p><p>对于<code>var foo = 0;</code>来说,编译器首先在当前作用域声明一个变量foo,之后在运行时JS引擎会从当前作用域中查找变量foo,再然后将数字0赋值给变量foo.</p><h4 id="scope-chain-作用域链"><a href="#scope-chain-作用域链" class="headerlink" title="scope chain(作用域链)"></a>scope chain(作用域链)</h4><p>每一个函数都有自己的执行环境,当函数嵌套在另一个函数或块中,就会形成作用域链.作用域链的前端就是当前执行环境,全局执行环境的变量即作用域链的顶端.在当前作用域中找不到变量时,JS引擎会沿着作用域链一级一级向上查询,直到找到为止.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>上面的例子中,foo的作用域中没有变量a,需要使用变量a需要向上一级查找.</p><h4 id="LHS-and-RHS"><a href="#LHS-and-RHS" class="headerlink" title="LHS and RHS"></a>LHS and RHS</h4><p>JS引擎进行变量查询的方式有两种,分别是LHS和RHS.LHS表示查询赋值操作的目标,RHS表示查询赋值操作的源头.简单的说,LHS查询是寻找这个变量的容器本身,从而进行赋值操作,RHS查询是查找某个变量的值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>对上面的例子进行分析:</p><ul><li>要执行函数foo,需要知道其赋值操作的源头,从而进行RHS引用</li><li>接下来把数字1赋值给函数foo的形参a,需要进行一次LHS引用,这是一个隐式变量分配</li><li>对console进行RHS引用,console是一个内置对象,有log()方法</li><li>确认形参a的值,进行一次RHS查询,将形参a的值传递给console对象的log()方法</li></ul><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>如果RHS查询在所有的作用域链都没有找到所需的变量时,JS引擎就会抛出ReferenceError异常.如果RHS查询到目标变量,但尝试进行非法操作时,JS引擎会抛出TypeError异常.<br>如果LHS查询在所有的作用域链中都找不到所需的变量时,就会在全局作用域中创建该变量并返还给JS引擎.</p><blockquote><p>注意: 严格模式中禁止自动或隐式创建变量,LHS查询失败时同样会返回ReferenceError异常.</p></blockquote><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p>作用域一般有两种工作模式,一种是为大多数语言使用的词法作用域,另一种是动态作用域.</p><p>词法作用域就是定义在词法阶段的作用域.词法作用域是由书写代码是函数声明位置决定的.作用域一旦确定基本上会保持不变.当然也有欺骗词法的方法,但不推荐使用,欺骗作用域会导致性能下降.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域,只有foo标识符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">m</span>) </span>&#123; <span class="comment">// foo的作用域,m,n和bar三个标识符</span></span><br><span class="line">  <span class="keyword">var</span> n = m - <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123; <span class="comment">// bar的作用域,只有x标识符</span></span><br><span class="line">    <span class="built_in">console</span>.log(m, n, x);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(n + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="欺骗词法-eval"><a href="#欺骗词法-eval" class="headerlink" title="欺骗词法-eval"></a>欺骗词法-eval</h4><p>eval()方法会接收一个字符串作为参数,并将字符串视作代码片段进行执行.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">str,a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="string">'var b = 4'</span>, <span class="number">2</span>); <span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure><blockquote><p>严格模式下,eval()方法创建的变量不能被调用.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">str, a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="string">'var b = 4'</span>, <span class="number">2</span>); <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>使用eval()方法生成代码将造成性能上的损失,不推荐使用.</p></blockquote><h4 id="欺骗词法-with"><a href="#欺骗词法-with" class="headerlink" title="欺骗词法-with"></a>欺骗词法-with</h4><p>with()方法会将一个对象的引用当作作用域来处理,将对象的属性当作作用域的标识符来处理,从而创建一个新的作用域.这种方法也会使JS引擎在编译时无法对作用域进行优化,从而造成性能上的损失.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'one'</span>,</span><br><span class="line">  b: <span class="string">'two'</span>,</span><br><span class="line">  c: <span class="string">'three'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">  a = <span class="string">'four'</span>,</span><br><span class="line">  b = <span class="string">'five'</span>,</span><br><span class="line">  c = <span class="string">'seven'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>严格模式中with()方法被完全禁止.</p></blockquote><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><blockquote><p>属于这个函数的全部变量可以在整个函数内部或其嵌套的作用域内部使用,这即是函数的作用域.</p></blockquote><p>1.隐藏内部实现</p><p>函数作用域可以将声明在该函数内部的变量或函数隐藏起来,从而实现良好的设计模式.在模块和对象的API设计中,这种方法很常见也很实用.</p><p>下面是利用对象全局命名空间来规避冲突的方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameSpace = &#123;</span><br><span class="line">  doSomeThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  doAnotherThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>2.立即执行函数表达式(IIFE)</p><p>我们希望函数不需要函数名或者函数名不会污染所在的作用域,并且能够自动执行.这是我们可以使用IIFE来实现.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  a: <span class="string">'zero'</span>,</span><br><span class="line">  b: <span class="string">'one'</span>,</span><br><span class="line">  c: <span class="string">'two'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">global</span>) </span>&#123; <span class="comment">// 将bar对象的引用传递进去,参数命名为global</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'three'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// three</span></span><br><span class="line">  <span class="built_in">console</span>.log(global.a); <span class="comment">// zero</span></span><br><span class="line">&#125;)(bar);</span><br></pre></td></tr></table></figure><h4 id="块作用域-try-catch"><a href="#块作用域-try-catch" class="headerlink" title="块作用域(try..catch)"></a>块作用域(try..catch)</h4><p>ES3中规定try..catch会创建一个块级作用域,其中声明的变量仅在catch内部有效.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 正常执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(err); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><h4 id="块作用域-let"><a href="#块作用域-let" class="headerlink" title="块作用域-let"></a>块作用域-let</h4><p>ES6中引用了let关键字,可以将变量绑定到任意的作用域中.let将其声明的变量隐式的放到了它所在的块作用域中.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 正常执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用&#123;..&#125;显式声明变量</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure></p><h4 id="块作用域-const"><a href="#块作用域-const" class="headerlink" title="块作用域-const"></a>块作用域-const</h4><p>ES6中引入了const关键字,用来声明常量.同样可以用来创建块作用域.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">9</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure></p><blockquote><p>声明在这个作用域中的变量都将作用在这个作用域中.</p></blockquote><h4 id="函数和变量提升"><a href="#函数和变量提升" class="headerlink" title="函数和变量提升"></a>函数和变量提升</h4><p>作用域中的声明将在代码本身执行之前首先处理,将这个过程想象成所用声明(变量和函数)都会被移动到各自作用域的前端,这个过程称为提升.</p><blockquote><p>先有声明后有赋值.只有函数和变量会进行提升</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码,编译器会把声明var a;提升到全局顶部首先进行处理,即按照如下顺序处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有声明本身会被提升,赋值和其它逻辑语句会停留在原地</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器把var a = 0;视为两部分,即var a;和a = 0;</span></span><br><span class="line"><span class="comment">// 将var a;提升到全局顶部,首先进行处理,赋值操作a = 0;留在原地.</span></span><br><span class="line"><span class="comment">// 编译器会按照如下形式处理这段代码:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个作用域只会在自己的作用域范围内进行提升</span></span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码块中,全局作用域中的函数声明会被提升,bar函数作用域中的var a;也会被提升</span></span><br><span class="line"><span class="comment">// 即按照下面的顺序进行处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><blockquote><p>函数首先会被提升,然后才是变量.要避免重复声明,当变量声明和函数声明混合在一起容易造成混乱.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作用域是一套用于确定在何处以及如何查找变量的规则.赋值操作会导致LHS查询,获取变量值的操作会导致RHS查询.引擎在处理代码时会优化处理变量声明和函数声明,这种机制叫做提升.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;JavaScript
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>The History Of JavaScript</title>
    <link href="https://yieeo.github.io/2017/11/21/JavaScript-history/"/>
    <id>https://yieeo.github.io/2017/11/21/JavaScript-history/</id>
    <published>2017-11-20T23:53:54.000Z</published>
    <updated>2018-10-13T08:20:35.133Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是由Netscape Communications Corporation(网景公司)程序员Brendan Eich(布兰登.艾克)于1995年创造出来的.Eich只用了10天就开发出了这门脚本语言,最初命名为Mocha.</p><p>1995年9月网景公司在自己的Netscape Navigator浏览器2.0中将这门语言改名为LiveScript.同年12月,网景公司为了将这门语言搭上Java这个编程语言”热词”,随后又改名为JavaScript,但是这门语言与Java没有任何关系.随后JavaScript在浏览器上大获成功,不久后微软公司在自己的Internet Explorer浏览器上推出了JScript,与网景公司进行同台竞争.JScript也是一种JavaScript的实现,这两个的语言版本的共存使得浏览器的语言标准化的缺失.微软在自己的网页技术上加入一些的自己的专属方法,使得网页在不同的浏览器的效果呈现出的不同的效果,程序员写一份代码无法在不同的浏览器上呈现出相同的效果,对于相应的浏览器必须写兼容相应浏览器的代码.语言实现的不同专有化DOM(文档对象模型)的差异,成为了网络上普及JavaScript的阻碍.</p><p>终于在1996年11月,网景公司正式向ECMA(欧洲计算机制造商协会)提交语言标准.1997年6月,ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262.ECMA标准.流程以循环方式运行 - ECMAScript 2于1998年发布,ECMAScript 3于1999年发布(演变为今天的现代JavaScript).尽管微软开始用JScript语言实现一些提议,但很明显微软不会在Internet Explorer中实现JavaScript.2005年,Eich和Mozilla加入ECMA协助E4X(ECMA-357),与Macromedia(被Adobe收购)合作,他们正致力于在ActionScript 3中实施E4X.这种合作的目标是标准化AS3中的内容并在SpiderMonkey中实现它.因此,Adobe发布了Tamarin,一个源自AVM2的开放课程项目.<br>开源社区和开发者社区也在努力彻底改变JavaScript以及可以用它做些什么,社区的影响达到了顶峰,Jesse James Garrett于2005年发布了一篇论文,其中描述了JavaScript支持的一组技术作为支柱.他创造了“Ajax”这个词.该文引发了大量开发人员倾向于JavaScript以及围绕它的开源社区和库.此外,jQuery,Prototype和Dojo是新发布的库之一.Ajax的优势使JavaScript成为人们关注的焦点,并带来了更多专业的编程注意力.结果是全面的框架和库的增加,以及在Web浏览器之外增加JavaScript的使用,正如服务器端JavaScript平台的激增.</p><p>截至2016年,统计数据显示,约92％的网站使用JavaScript - 其中包括一些全球最大的网站,如Google和Facebook.并且由于JavaScript,使这些网站成为现实的元素是可能的.例如,如果没有JavaScript,我们就不会拥有我们习以为常的实时通知.今天,JavaScript仍然无处不在 - 它是最常用的客户端脚本语言.JavaScript被写入HTML文档,并以许多独特的方式实现与网页的交互.例如,由于JavaScript,我们可以自动安排约会和玩在线游戏.此外,诸如Node.js之类的新开发允许在服务器端使用JavaScript,而诸如HTML5之类的API允许控制用户媒体和其他设备功能.</p><h4 id="JavaScript的组成部分"><a href="#JavaScript的组成部分" class="headerlink" title="JavaScript的组成部分"></a>JavaScript的组成部分</h4><ul><li>ECMAScript,描述了该语言的语法和基本对象</li><li>DOM(文档对象模型),描述了处理网页内容的方法和接口</li><li>BOM(浏览器对象模型),描述了与浏览器进行交互的方法和接口</li></ul><h4 id="JavaScript的基本特点"><a href="#JavaScript的基本特点" class="headerlink" title="JavaScript的基本特点"></a>JavaScript的基本特点</h4><p>JavaScript通常缩写为JS,是一种高级的,解释执行的编程语言.JavaScript是一门基于原型和函数先行的语言,是一门多范式的语言,它支持面向对象编程,命令式编程,以及函数式编程.随着最新的HTML5和CSS3语言标准的推行它还可以用于游戏,桌面和移动应用程序的开发和在服务器端网络环境运行,如Node.js</p><p>JavaScript由ECMA通过ECMAScript实现语言的标准化,已经被世界上绝大多数浏览器所使用,也被世界上的主流浏览器(Chrome,FireFox,Opera,Safari,IE)支持.</p><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>既然谈到了浏览器,就不得不谈谈现在的主流浏览器的内核,浏览器内核可以分为两部分:渲染引擎和JS引擎.最开始渲染引擎和JS引擎并没有区分的很明确,后来JS引擎(最著名的JS引擎就是Google的V8引擎,V8引擎也促进了后来Node.js的诞生)越来越独立,内核倾向于只指渲染引擎.</p><ul><li>Chrome浏览器内核: 统称为Chromium内核或Chrome内核,以前是Webkit内核,现在是Blink内核</li><li>FireFox浏览器内核: Gecko内核</li><li>Opera浏览器内核: 最初是自己的Presto内核,后与Google一起研发内核,使用过Webkit内核,现在是Blink内核</li><li>Safari浏览器内核: Webkit内核</li><li>IE浏览器内核: Trident内核</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript是由Netscape Communications Corporation(网景公司)程序员Brendan Eich(布兰登.艾克)于1995年创造出来的.Eich只用了10天就开发出了这门脚本语言,最初命名为Mocha.&lt;/p&gt;
&lt;p&gt;1995年9月网
      
    
    </summary>
    
    
  </entry>
  
</feed>
