<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yie&#39;s Blog</title>
  
  <subtitle>The power of imagination makes us infinite, Welcome to yie&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yieeo.github.io/"/>
  <updated>2018-12-23T05:33:34.053Z</updated>
  <id>https://yieeo.github.io/</id>
  
  <author>
    <name>yie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Introduction to HTTP</title>
    <link href="https://yieeo.github.io/2018/08/17/HTTP-introduction/"/>
    <id>https://yieeo.github.io/2018/08/17/HTTP-introduction/</id>
    <published>2018-08-16T16:00:00.000Z</published>
    <updated>2018-12-23T05:33:34.053Z</updated>
    
    <content type="html"><![CDATA[<p>超文本传输协议(HTTP)是用于分布式, 协作, 超媒体系统的应用层协议. 设计HTTP的初衷是解决HTML页面的发布和接收问题, HTTP是万维网数据通信的基础. HTTP的全称为<code>HyperText Transfer Protocol</code>.HTTP遵循经典的客户端-服务端模型, 客户端打开一个连接以发出请求, 然后等待它收到服务器端响应. HTTP是一种无状态协议, 意味着服务器不会再两个请求之间保留任何数据(状态). 虽然HTTP是基于TCP/IP层之上的, 但可以在任何可靠的传输层上使用.</p><p>1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法, 并称之为超文本, 这也成为HTTP超文本传输协议标准架构的发展根基. HTTP的开发由Tim Berners-Lee于1989年在欧洲核子研究中心(CERN)发起, HTTP标准的开发由互联网工程任务小组(IETF)和万维网联盟(W3C)协调, 最终发布了一系列标准.</p><h4 id="HTTP的版本"><a href="#HTTP的版本" class="headerlink" title="HTTP的版本"></a>HTTP的版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------</span><br><span class="line">      年份      |       HTTP版本   </span><br><span class="line">--------------------------------------------------------</span><br><span class="line">      1991年    |         0.9</span><br><span class="line">      1996年    |         1.0</span><br><span class="line">      1997年    |         1.1</span><br><span class="line">      2015年    |         2.0</span><br><span class="line">--------------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h4><ul><li><p>简单快速: 客户端向服务器请求服务时, 只需传送请求方法和路径. 请求方法常见的有GET, HEAD, PUT, DELETE, POST. 每种方法规定了客户与服务器联系的类型不同, 由于HTTP协议简单, 使得HTTP服务器的程序规模小, 因此通信速度很快.</p></li><li><p>灵活: HTTP允许传输任意类型的数据对象.</p></li><li><p>无连接: 限制每次连接只处理一个请求. 服务器处理完客户的请求, 并收到客户的应答后, 断开连接, 采用这种方式可以节省传输时间.</p></li><li><p>无状态: HTTP协议自身不对请求和相应之间的通信状态进行保存. 任何两次请求之间都没有依赖关系, 每个请求都是独立的, 与前面的请求和后面的请求都是没有直接联系. 协议本身不保存之前一切的请求报文或相应报文的信息. 这是为了更快的处理大量事务, 确保协议的可伸缩性.</p></li></ul><h4 id="HTTP消息格式"><a href="#HTTP消息格式" class="headerlink" title="HTTP消息格式"></a>HTTP消息格式</h4><p>客户端和服务器通过发送纯文本消息进行通信. 客户端向服务器发送请求, 服务器发送相应.</p><p>请求消息包含如下内容:</p><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求体</li></ul><p>响应消息包含如下内容:</p><ul><li>状态行</li><li>响应头</li><li>空行</li><li>响应体</li></ul><h4 id="HTTP持久连接"><a href="#HTTP持久连接" class="headerlink" title="HTTP持久连接"></a>HTTP持久连接</h4><p>在HTTP/0.9和1.0中, 连接在单个请求/相应之后关闭的, 在HTTP/1.1中引入了keep-alive-mechanism, 其中连接可以被重用于多个请求. 这种持久连接可以明显地减少请求延迟, 因为客户端在发送了第一个请求之后不需要重新协商TCP 3-Way-Handshake连接. 由于TCP的慢启动机制, 连接随着时间的推移变得更快.</p><p>该协议的1.1版还对HTTP/1.0进行了带宽优化改进. HTTP1.1引入了分块传输编码, 以允许流传输持久连接上的内容而不是缓冲. HTTP流水线操作进一步缩短了延迟时间, 允许客户端在等待每个响应之前发送多个请求. 协议的另一个附加功能是字节服务, 其中服务器仅传输客户端明确请求的资源部分. </p><h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>HTTP请求方法是指要对所识别的资源执行的期望动作.</p><ul><li>GET: 请求指定的内容信息, 返回响应主体.</li><li>HEAD: 与GET类似, 但没有响应主体. 这对于检索在响应头中编写的元信息非常有用, 而无需传输整个内容.</li><li>POST: 向指定资源提交数据进行处理请求, 数据包含在请求体中.</li><li>PUT: 将所包含的实体存储在指定的URI下. 如果URI引用已存在资源, 则将其修改; 如果URI未指定现有资源, 则在给URI下创建资源.</li><li>DELETE: 删除指定的资源.</li><li>TRACE: 回应收到的请求, 以便客户端可以查看中间服务器所做的更改和添加.</li><li>OPTIONS: 返回服务器支持指定的URL的HTTP方法, 这可以通过请求而不是特定资源来检查Web服务器的功能.</li><li>CONNECT: 将请求连接转换为透明的TCP/IP隧道, 通常是为了通过为加密的HTTP代理促进SSL加密通信(HTTPS).</li><li>PATCH: 对资源应用部分修改.</li></ul><p>所用通用HTTP服务器都需要至少实现GET和POST方法, 并且规范认为所有的其它方法都是可选的.</p><h4 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h4><ul><li>浏览器刷新/后退: GET没有任何影响, POST会把数据重新提交</li><li>书签: GET可收藏为书签, POST不可收藏为书签</li><li>缓存: GET能被缓存, POST不能被缓存</li><li>编码类型: GET采用<code>application/x-www-form-urlencoded</code>编码, POST采用<code>application/x-www-form-urlencoded</code>或者<code>multipart/form-data</code>编码, 为二进制数据使用多重编码</li><li>浏览器保存历史: GET参数保留在浏览器历史中, POST参数不会保存在浏览器历史中</li><li>数据长度限制: GET的URL最大长度为2048个字符, POST无长度限制</li><li>数据类型限制: GET只允许ASCII字符, POST无限制, 也可以使用二进制数据</li><li>安全性: GET安全性较差, 敏感数据最好不要使用, POST参数不会保存在浏览器历史或Web服务器的日志中, 比GET安全</li><li>可见性: GET数据在URL中所有人可见, POST不会显示在URL中</li></ul><h4 id="HTTP状态代码"><a href="#HTTP状态代码" class="headerlink" title="HTTP状态代码"></a>HTTP状态代码</h4><p>在HTTP/1.0中, HTTP响应的第一行称为状态行, 包括数字状态代码(例如:404)和文本原因短语(例如: Not Found). 用户代理处理响应的方式主要取决于代码, 其次取决于其它响应头字段. 可以使用自定义状态代码, 因为如果用户代理遇到它无法识别的代码, 它可以使用代码的第一个数字来确定响应的一般类.</p><p>HTTP状态代码主要分为五组, 以便更好地解释客户端和服务器之间的请求和响应.</p><ul><li>1xx: 信息性状态码, 接收的请求正在处理</li><li>2xx: 成功状态码, 请求正常处理完毕</li><li>3xx: 重定向状态码, 需要进行附加操作以完成请求</li><li>4xx: 客户端错误状态码, 服务器无法处理请求</li><li>5xx: 服务器错误状态码, 服务器处理请求出错</li></ul><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><p><strong><em> 200 OK </em></strong><br>请求成功. 成功的含义取决于HTTP方法:</p><ul><li>GET: 资源已被提取并在消息正文中传输</li><li>HEAD: 实体标头位于消息正文中</li><li>POST: 描述动作结果的资源在消息体中传输</li><li>TRACE: 消息正文包含服务器收到的请求消息</li></ul><p><strong><em> 204 No Content </em></strong><br>服务器成功处理了请求, 但不需要返回任何实体内容, 并且希望返回更新了的元信息. 响应可能通过实体头部的形式, 返回新的或更新的元信息. 如果存在这些头部信息, 则应当与所请求的变量相呼应. 如果客户端是浏览器的话, 那么用户浏览器应保留发送了该请求的页面, 而不产生任何文档视图上的变化. 即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档. 由于204响应被禁止包含任何消息体, 因此它始终以消息头后的第一个空行结尾.</p><p><strong><em> 206 Partial Content </em></strong><br>服务器已经成功处理了部分GET请求. 类似于FlashGet或者迅雷这类的HTTP下载工具都是使用此类响应实现断点续传或者建一个大文档分解为多个下载段同时下载. 该请求必须包含Range头信息来指示客户端希望得到的内容范围, 并且可能包含if-Range来作为请求条件.</p><p><strong><em> 301 Moved Permanently </em></strong><br>被请求的资源已永久移动到新位置, 并且将来任何对此资源的引用都应该使用本响应返回的若干个URL之一. 如果可能, 拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址. 除非额外指定, 否则这个响应也是可缓存的.</p><p><strong><em> 302 Found </em></strong><br>请求的资源现在临时从不同的URI响应请求. 由于这样的重定向是临时的客户端应当继续向原有地址发送以后的请求, 只有在Cache-Control或在Expires中进行了指定的情况下, 这个响应才是可缓存的.</p><p><strong><em> 303 See Other </em></strong><br>对应当前请求的响应可以在另一个URI上被找到, 而且客户端应当采用GET的方式访问那个资源. 这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源.</p><p><strong><em> 304 Not Modified </em></strong><br>如果客户端发送了一个带条件的GET请求且该请求已被允许, 而文档的内容(自上次访问以来或者根据请求的条件)并没有改变, 则服务器应当返回这个状态码. 304响应禁止包含消息体, 因此始终以消息头后的第一个空行结尾.</p><p><strong><em> 307 Temporary Redirect </em></strong><br>请求的资源现在临时从不同的URI响应请求. 由于这样的重定向是临时的, 客户端应当继续向原有地址发送以后的请求. 只有在Cache-Control或Expires中进行了指定的情况下, 这个响应才是可缓存的.</p><p><strong><em> 400 Bad Request </em></strong></p><ol><li>语义有误, 当前请求无法被服务器理解. 除非进行修改, 否则客户端不应该重复提交这个请求.</li><li>请求参数有误</li></ol><p><strong><em> 401 Unauthorized </em></strong><br>当前请求需要用户验证. 该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息. 客户端可以重复提交一个包含恰当的Authorization头信息的请求. 如果当前请求已经包含了Authorization证书, 那么401响应代表着服务器验证已经拒绝了那些证书. 如果401响应包含了与前一个响应相同的身份验证询问, 且浏览器已经至少尝试了一次验证, 那么浏览器应当向用户展示响应中包含的实体信息, 因为这个实体信息中可能包含了相关诊断信息.</p><p><strong><em> 403 Forbidden </em></strong><br>服务器已经理解请求, 但是拒绝执行它. 与401响应不同的是, 身份验证并不能提供任何帮助, 而且这个请求也不应该被重复提交. 如果这不是一个HEAD请求, 而且服务器希望能够讲清楚为何请求不能被执行, 那么就应该在实体内描述拒绝的原因. 当然服务器也可以返回一个404响应, 假如它不希望让客户端获得任何信息.</p><p><strong><em> 404 Not Found </em></strong><br>请求失败, 请求所希望得到的资源未被在服务器上发现. 没有信息能够告诉用户这个状态码到底是暂时的还是永久的.</p><p><strong><em> 500 Internal Server Error </em></strong><br>服务器遇到了不知道如何处理的情况.</p><p><strong><em> 503 Service Unavailable </em></strong><br>服务器没有准备好处理请求. 常见原因是服务器因维护或重载而停机.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;超文本传输协议(HTTP)是用于分布式, 协作, 超媒体系统的应用层协议. 设计HTTP的初衷是解决HTML页面的发布和接收问题, HTTP是万维网数据通信的基础. HTTP的全称为&lt;code&gt;HyperText Transfer Protocol&lt;/code&gt;.HTTP遵
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://yieeo.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>ReactJS JSX</title>
    <link href="https://yieeo.github.io/2018/07/10/ReactJS-JSX/"/>
    <id>https://yieeo.github.io/2018/07/10/ReactJS-JSX/</id>
    <published>2018-07-10T08:59:44.000Z</published>
    <updated>2018-12-04T15:12:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>JSX(JavaScript and XML)是ReactJS定义的一种JavaScript语法扩展. JSX是可选的, 我们完全可以使用JavaScript编写ReactJS应用, 不过JSX提供一套更为简洁的方式来写ReactJS应用.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用JSX</span></span><br><span class="line"><span class="keyword">const</span> bar = (</span><br><span class="line">  &lt;h1 className=<span class="string">'bingo'</span>&gt;</span><br><span class="line">    hello world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用JSX</span></span><br><span class="line"><span class="keyword">const</span> bar = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">'bingo'</span> &#125;,</span><br><span class="line">  <span class="string">'hello world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但是JSX有以下优点:</p><ul><li>它更快, 因为它将代码编译为JavaScript时执行优化</li><li>它很安全, 编译期间可以捕获大多数错误</li><li>你熟悉HTML, 可以很轻松, 快速的编写模板</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JSX中括号内允许放置任何有效的JavaScript表达式</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;hello, &#123; name &#125;&lt;/h1&gt;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>当JSX拆分为多行时, 我们应该将其包在一个括号内, 避免浏览器自动插入分号</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以在if语句和for循环中使用JSX, 将其分配给变量, 接收它作为参数, 并从函数返回它</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;hello, &#123; user &#125;!&lt;/h1&gt;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;hello, Mary!&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以使用引号将字符串文字指定为属性</span></span><br><span class="line"><span class="keyword">const</span> bar = &lt;div tabIndex='0'&gt;&lt;/div&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以使用大括号在属性中嵌入JavaScript表达式</span></span><br><span class="line"><span class="keyword">const</span> bar = &lt;img src=&#123; user.name &#125;&gt;&lt;/img&gt;;</span><br></pre></td></tr></table></figure><blockquote><p>在JSX的标签中的同一属性上不能同时使用引号和大括号, JSX中采用<code>cameCase</code>(驼峰式)属性命名约定, <code>class</code>属性应该变成<code>className</code>, <code>tabindex</code>属性应该变成<code>tabIndex</code>, <code>for</code>属性应该变成<code>htmlFor</code>.</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JSX中所有标签都要闭合</span></span><br><span class="line"><span class="keyword">const</span> bar = &lt;img src=&#123; user.name &#125; /&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JSX中的标签可以包含子标签</span></span><br><span class="line"><span class="keyword">const</span> bar = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;what a wonderful world.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JSX中使用注释</span></span><br><span class="line"><span class="keyword">const</span> bar = (</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// comment</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#123;<span class="comment">/* comment */</span>&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      comment</span></span><br><span class="line"><span class="comment">      ...</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;p&gt;what a wonderful world.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>总结:</p><ul><li>在JSX中可以插入任何JavaScript表达式, 表达式需要用<code>{}</code>包裹起来, 插入字符串用<code>&quot;&quot;</code>包裹</li><li>JSX表达式可以像JavaScript对象一样, 可以被赋值, 传参和<code>return</code></li><li>JSX分割成多行时, 需要使用<code>()</code>包裹起来, 避免浏览器自动插入分号</li><li>JSX中的所有标签必须闭合</li><li>JSX属性采用驼峰式命名, <code>class</code>属性应该写成<code>className</code>, <code>tabindex</code>属性应该写成<code>tabIndex</code>, <code>for</code>属性应该写成<code>htmlFor</code></li><li>JSX在渲染之前, 所有东西转换为字符串, 可以防止XSS攻击</li><li>Babel通过调用<code>React.createElement()</code>API来编译JSX, React必须在JSX代码的作用域内</li><li>JSX通过<code>React.createElement()</code>API将JSX转化为React Object</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSX(JavaScript and XML)是ReactJS定义的一种JavaScript语法扩展. JSX是可选的, 我们完全可以使用JavaScript编写ReactJS应用, 不过JSX提供一套更为简洁的方式来写ReactJS应用.&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
      <category term="ReactJS" scheme="https://yieeo.github.io/tags/ReactJS/"/>
    
  </entry>
  
  <entry>
    <title>Learn ReactJS</title>
    <link href="https://yieeo.github.io/2018/06/22/Learn-ReactJS/"/>
    <id>https://yieeo.github.io/2018/06/22/Learn-ReactJS/</id>
    <published>2018-06-22T13:15:55.000Z</published>
    <updated>2018-12-04T15:09:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>ReactJS是Facebook开发的UI库, 这个库有助于创建交互式, 基于状态和可重用的UI库. ReactJS已经用于Facebook自己的Instagram项目. ReactJS不仅可以运行在客户端, 也可以用于服务器端, 从而使客户端和服务器端协同操作.</p><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><p>在Web开发中, 需要不断变化数据实时显示在UI上, 这时就要操作DOM, 复杂频繁操作DOM就会下降Web性能. ReactJS为了解决这个性能瓶颈, 引入了虚拟DOM(Virtual DOM), 这也是ReactJS最为重要的核心机制之一. ReactJS利用虚拟DOM来减少对真实DOM的操作而提升性能. 由于虚拟DOM是在内存中创建的, 性能极高. 它可以根据状态的变化, 有选择的渲染节点和子节点, 为了更新部件, ReactJS做尽量少的DOM处理操作. 开发者不用关心数据是如何变化的, 只需要知道每一次页面渲染对应的整体数据就行了. 在ReactJS的开发中, 你永远只需要关心整体数据. 由于ReactJS使用的是虚拟的DOM, 这就产生一种新的可能, 我们可以在服务器端渲染虚拟的DOM, 快速更新视图.</p><h4 id="组件化思想"><a href="#组件化思想" class="headerlink" title="组件化思想"></a>组件化思想</h4><blockquote><p>组件: 封装起来具有独立功能的UI部件</p></blockquote><p>在虚拟DOM的基础上衍生了ReactJS组件化的开发思路, ReactJS刚出现时, 犹如一记重磅炸弹, 轰动Web前端领域, 原来还可以以这种方式开发网页, ReactJS后来还衍生出了React Native项目, 可以通过Web APP的方式去写Native APP, React Native项目在GitHub平台上发布一天之内获得了5000star. ReactJS先进的设计思想也影响了后来的一些的JS框架和库. VueJS就可以寻到一些ReactJS设计思想的影子.</p><p>ReactJS接管了开发UI中最为复杂的局部更新数据的部分. 局部更新数据实现的途径就是通过虚拟DOM, 局部更新数据最重要就是ReactJS的Diff算法. 同时引入组件化的开发思想从另一个角度构建Web前端页面. 在ReactJS构建的应用程序中, 可以将整个页面视为一个由许多子组件构成的大组件, 这样最明显的好处就是增加代码的可用性, 一个组件可以在多个UI界面中使用.</p><p>Diff算法基于两种假设:</p><ul><li>不同类型组件产生不同DOM结构</li><li>对于同一层次的一组子组件, 可以通过唯一的id进行区分</li></ul><p>ReactJS组件应具备的三个特征:</p><ul><li>可组合: 能够和其它组件一起使用</li><li>可维护: 每个组件只包含自己内部的逻辑代码, 更容易维护</li><li>可测试: 测试单个组件内部的逻辑代码相比较于测试整个UI代码更加容易</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ReactJS是Facebook开发的UI库, 这个库有助于创建交互式, 基于状态和可重用的UI库. ReactJS已经用于Facebook自己的Instagram项目. ReactJS不仅可以运行在客户端, 也可以用于服务器端, 从而使客户端和服务器端协同操作.&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="ReactJS" scheme="https://yieeo.github.io/tags/ReactJS/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6</title>
    <link href="https://yieeo.github.io/2018/05/06/JavaScript-ES6/"/>
    <id>https://yieeo.github.io/2018/05/06/JavaScript-ES6/</id>
    <published>2018-05-06T03:59:53.000Z</published>
    <updated>2018-12-04T15:07:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript6.0(简称ES6)是JavaScript语言的下一代标准, 已经在2015年6月正式发布了. 它的目标是使JavaScript可以用来编写复杂的大型应用程序, 成为企业级开发语言. 各个浏览器对ECMAScript6的支持可以查看 <a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es6/</a>.</p><h4 id="Babel转码器"><a href="#Babel转码器" class="headerlink" title="Babel转码器"></a>Babel转码器</h4><p><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>是一个广泛的ECMAScript6转码器, 可以将ECMAScript6代码转为ECMAScript5代码. 通过这种方式就不用担心当前环境是否支持ECMAScript6.</p><p>Babel提供了一个<a href="https://babeljs.io/repl/" target="_blank" rel="noopener">REPL在线编译器</a>, 可以在线将ECMAScript6代码转为ECMAScript5代码.</p><p>Babel还提供了<code>Babel-cli</code>工具, 可以使用命令行转码.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm是node.js包管理工具,使用npm命令必须先安装node.js</span></span><br><span class="line"><span class="comment"># 使用npm命令安装babel-cli工具</span></span><br><span class="line">$ npm i -g babel-cli</span><br></pre></td></tr></table></figure><p>基本用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转码结果输出到标准输出</span></span><br><span class="line">$ babel example.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码结果写入一个文件中</span></span><br><span class="line"><span class="comment"># -o(也可以使用--out-file参数)参数指定输出文件</span></span><br><span class="line">$ babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个目录转码</span></span><br><span class="line"><span class="comment"># -d参数(也可以使用--out-dir参数)指定输出目录</span></span><br><span class="line">$ babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s参数生成source map文件</span></span><br><span class="line">$ babel src -d lib -s</span><br></pre></td></tr></table></figure><h4 id="let和const关键字"><a href="#let和const关键字" class="headerlink" title="let和const关键字"></a>let和const关键字</h4><p>ECMAScript6新增了let关键字, 用来声明变量. 它的用法与var关键字类似, 但是用let关键字声明的变量, 只在let关键字所在的代码块内有效, 不会和var关键字一样发生变量提升.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>ECMAScript6明确规定, 区块中存在let和const关键字, 这个区块对这些声明的变量和常量, 从一开始就形成了封闭作用域. 只要在声明之前使用这些变量和常量, 就会报错.</p><p>在代码块中, 使用let关键字声明变量之前, 该变量是不可用的, 这在语法上称为<code>TDZ</code>(暂时性死区).</p><p>let关键字不允许在相同作用域中重复声明同一变量, let关键字为JavaScript新增了块级作用域, ECMAScript6引入了块级作用域, 明确允许在块级作用域中声明函数.</p><p>const关键字用来声明一个只读常量, 声明过后, 常量的值就不能改变. const关键字声明的常量也是不提升的, 也存在<code>TDZ</code>, 只能在声明之后使用常量.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于复合类型的常量, 常量名不指向数据, 而是指向数据所在的地址. const关键字只保证变量名指向地址不变, 并不保证该地址的数据不变.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  bar: <span class="string">'zero'</span>,</span><br><span class="line">  bingo: <span class="string">'four'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bingo = <span class="string">'two'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bingo); <span class="comment">// two</span></span><br></pre></td></tr></table></figure><blockquote><p>ECMAScript6规定var关键字和function关键字声明的全局变量, 依旧是全局对象的属性; let关键字, const关键字和class关键字声明的全局变量和常量, 不属于全局对象的属性</p></blockquote><h4 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [foo, [[bar], bingo]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(bingo); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构数组允许指定默认值</span></span><br><span class="line">[foo, bar = <span class="number">1</span>] = [<span class="number">3</span>]; <span class="comment">// foo = 3, bar = 1</span></span><br><span class="line">[foo, bar = <span class="number">1</span>] = [<span class="number">3</span>, <span class="literal">undefined</span>]; <span class="comment">// foo = 3, bar = 1</span></span><br></pre></td></tr></table></figure><blockquote><p>ECMAScript6内部使用严格相等相等符(===)判断一个值. 如果一个数组成员不严格等于undefined,默认值不会生效.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的解构赋值</span></span><br><span class="line"><span class="keyword">var</span> &#123; bar, foo &#125; = &#123; <span class="attr">bar</span>: <span class="string">'one'</span>, <span class="attr">foo</span>: <span class="string">'two'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// one</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// two</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">bar</span>: bingo &#125; = &#123; <span class="attr">bar</span>: <span class="string">'one'</span>, <span class="attr">foo</span>: <span class="string">'two'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bingo); <span class="comment">// one</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// error: bar is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>对象的解构与数组有一些不同. 数组的元素是按次序排序的, 变量的取值由它的位置决定, 而对象的属性没有次序, 变量必须与属性同名, 才能取得正确值.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数的解构赋值</span></span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>], [<span class="number">7</span>, <span class="number">2</span>]].map(<span class="function"><span class="keyword">function</span>(<span class="params">[a, b]</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;); <span class="comment">// [6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的解构赋值用作:</span></span><br><span class="line"><span class="comment">// 交换变量的值</span></span><br><span class="line"><span class="comment">// 提交JSON的值</span></span><br><span class="line"><span class="comment">// 函数参数的默认值</span></span><br></pre></td></tr></table></figure><h4 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// includes(): 返回布尔值, 表示是否找到参数字符串</span></span><br><span class="line"><span class="comment">// startWidth(): 返回布尔值, 表示参数字符串是否在源字符串的头部</span></span><br><span class="line"><span class="comment">// endsWidth(): 返回布尔值, 表示参数字符是否在源字符串的尾部</span></span><br><span class="line"><span class="comment">// 第二个参数n, endsWidth()方法与另两个方法不同, 它针对前n个字符</span></span><br><span class="line"><span class="comment">// 另两个方法第二个参数n针对从第n个位置直到字符串结束</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="string">'hello world!'</span>;</span><br><span class="line">bar.startWidth(<span class="string">'world'</span>, <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line">bar.endsWidth(<span class="string">'hello'</span>, <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line">bar.includes(<span class="string">'hello'</span>, <span class="number">6</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// repeat()方法返回一个新字符串, 表示将源字符串重复n次</span></span><br><span class="line"><span class="comment">// 'bingo'.repeat(2); // 'bingobingo'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// padStart()方法用于头部补全</span></span><br><span class="line"><span class="comment">// padEnd()方法用于尾部补全</span></span><br><span class="line"><span class="comment">// 第一个参数用来指定字符串的最小长度</span></span><br><span class="line"><span class="comment">// 第二个参数用来补全的字符串</span></span><br><span class="line"><span class="string">'go'</span>.padStart(<span class="number">5</span>, <span class="string">'a'</span>); <span class="comment">// 'aaago'</span></span><br><span class="line"><span class="string">'go'</span>.padStart(<span class="number">4</span>, <span class="string">'abc'</span>); <span class="comment">// 'abgo'</span></span><br><span class="line"><span class="string">'go'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>); <span class="comment">// 'goaba'</span></span><br><span class="line"><span class="string">'go'</span>.padEnd(<span class="number">3</span>,<span class="string">'abcd'</span>); <span class="comment">// 'goa'</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板字符串是增强版的字符串, 用反引号标识. 它可以当作普通字符串使用</span></span><br><span class="line"><span class="comment">// 也可以用来定义多行字符串或者字符串嵌入变量</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'Mike'</span>, time = <span class="string">'today'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span>); <span class="comment">// Hello Mike, how are you today?</span></span><br></pre></td></tr></table></figure><h4 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h4><blockquote><p>在ECMAScript5开始, 严格模式中八进制不再允许使用前缀<code>0</code>表示, 要使用前缀<code>0o</code>表示</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number.isFinite()方法: 检查一个数字是否无穷(infinity)</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.0008</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number.isNaN()方法: 检查一个值是否为NaN(not a number)</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">10</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>它们与传统的全局方法isFinite()和isNaN()的区别, 传统方法先调用Number将非数值的值转为数值, 在进行判断, 这两个新方法只对数值有效, 非数值一律返回false.</p><p>Number.parseInt(), Number.parseFloat():<br>ECMAScript6将全局方法parseInt()和parseFloat()移植到了Number对象上, 作用完全保持不变.</p><p>Number.isInteger():<br>用来判断一个值是否为整数, 在JavaScript内部, 整数和浮点数是同样的存储方法, 4和4.0被视为同一个值.</p><p>安全整数和Number.isSafeInteger():<br>JavaScript能准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间(不含两个端点), 超过范围, 无法精确表示.</p><p>ECMAScript6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>两个常量, 用来表示这个范围的上下限.<br>Number.isSafeInteger()方法用来判断一个整数是否在这个范围内.</p><p>Math对象的扩展</p><ul><li>Math.trunc()方法用于去除一个数的小数部分, 返回整数部分.</li><li>Math.sign()方法用来判断一个数是正数, 负数还是零.</li><li>Math.cbrt()方法用来计算一个数的立方根.</li><li>Math.fround()方法返回一个数的单精度浮点数形式.</li><li>Math.hypot方法返回所有参数的平方和的平方根.</li></ul><h4 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.from()方法用于将两类对象转为真正的数组:</span></span><br><span class="line"><span class="comment">// 类似数组的对象(array-like object)和可遍历(iterable)的对象(包括新增的数据结构Set和Map)</span></span><br><span class="line"><span class="comment">// 常见的类似数组的对象是DOM操作返回的NodeList集合, 以及函数内部的arguments对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(foo).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">let</span> bingo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.of()方法: 将一组值,转为数组形式</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>); <span class="comment">// [1, 5, 8]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实例的copyWithin()方法</span></span><br><span class="line"><span class="comment">// Array.prototype.copyWithin(target, start = 0, end = this.length)</span></span><br><span class="line"><span class="comment">// 第一个参数target(必需): 从该位置开始替换数据</span></span><br><span class="line"><span class="comment">// 第二个参数start(可选): 从该位置开始读取数据,默认为0.如果为负数,表示倒数</span></span><br><span class="line"><span class="comment">// 第三个参数end(可选): 到该位置停止读取数据,默认等于数组长度.如果为负数,表示倒数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实例的find()方法: 找出第一个符合条件的数组元素</span></span><br><span class="line"><span class="comment">// 参数为一个回调函数, 所有数组元素依次执行该回调函数, 直到找到第一个返回值为true的元素, 返回该元素</span></span><br><span class="line"><span class="comment">// 没有符合条件的元素, 返回undefined</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">-8</span>, <span class="number">6</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// -8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组实例的findIndex()方法用法与find()方法类似</span></span><br><span class="line"><span class="comment">// 不过返回的是第一个符合条件的数组元素的索引, 没有符合田间的元素,返回-1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">-8</span>, <span class="number">6</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fill()方法使用给定值, 填充一个数组</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>].fill(<span class="number">4</span>); <span class="comment">// [4, 4, 4]</span></span><br></pre></td></tr></table></figure><p>ECMAScript6提供三个新方法–entries(), key()和values(), 用于遍历数组. 唯一区别是key()方法是对键名的遍历, values()方法是对键值的遍历,entries()方法是对键值对的遍历.</p><h4 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="comment">// ECMAScript6允许使用"箭头"( =&gt; )定义函数</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="params">a</span> =&gt;</span> a;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数注意点:</p><ul><li>函数体内的this对象, 就是定义时所在的对象, 而不是使用时所在的对象</li><li>不可以当作构造函数, 不可以使用new关键字创建实例对象, 否则抛出一个错误</li><li>不可以使用arguments对象, 该对象在函数体中不存在. 如要使用Rest参数代替</li><li>不可以使用yield关键字, 箭头函数不能用作Generator函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMAScript6允许给函数的参数设置默认值</span></span><br><span class="line"><span class="comment">// 函数参数的默认值直接写在参数定义的后面</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="string">'one'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定默认之后, 函数的length属性可以返回没有指定默认值的参数个数</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">1</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">2</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ECMAScript6引入rest参数(形式为'...变量名')</span></span><br><span class="line"><span class="comment">// 用于获取函数的剩余参数</span></span><br><span class="line"><span class="comment">// rest参数搭配的变量是一个数组, 该变量将剩余的参数放入数组中</span></span><br><span class="line"><span class="comment">// rest参数之后不能再有参数, 否则报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展运算符(spread)是三个点( ... )</span></span><br><span class="line"><span class="comment">// 它好比rest参数的逆运算, 将一个数组转为用逗号分隔的参数序列</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>); <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"><span class="comment">// ECMAScript5写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// ECMAScript6写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用扩展运算符合并数组</span></span><br><span class="line"><span class="keyword">var</span> arrOne = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arrTwo = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"><span class="keyword">var</span> arrThree = [<span class="string">'f'</span>];</span><br><span class="line"><span class="comment">// ECMAScript5写法</span></span><br><span class="line">arrOne.concat(arrTwo, arrThree); <span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class="line"><span class="comment">// ECMAScript6写法</span></span><br><span class="line">[...arrOne, ...arrTwo, ...arrThree] <span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用扩展字符串将字符串转为数组</span></span><br><span class="line">[...<span class="string">'bingo'</span>] <span class="comment">// ['b', 'i', 'n', 'g', 'o']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Iterator接口的对象</span></span><br><span class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.getElementById(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">var</span> arr = [...nodeList];</span><br></pre></td></tr></table></figure><h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMAScript6允许在对象中, 可以不写属性值</span></span><br><span class="line"><span class="comment">// 这时属性值等于属性名所代表的变量</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Mary'</span>,</span><br><span class="line">  <span class="comment">// 等同于birthday: birthday</span></span><br><span class="line">  birthday,</span><br><span class="line">  <span class="comment">// 等同于say: function () ...</span></span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.assign()方法用于对象的合并</span></span><br><span class="line"><span class="comment">// 将源对象(source)的所有可枚举属性, 复制到目标对象(target)</span></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> sourceOne = &#123; <span class="attr">b</span>: <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> sourceTwo = &#123; <span class="attr">c</span>: <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, sourceOne, sourceTwo);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123; a: 1, b: 9, c: 6 &#125;</span></span><br></pre></td></tr></table></figure><p>如果目标对象与源对象有同名属性, 或多个源对象有同名属性, 则后面的属性会覆盖前面的属性. Object.assign()方法实现的是浅拷贝, 而不是深拷贝. 如果源对象某个属性值是对象, 那目标杜希昂拷贝得到的是这个对象的引用.</p><p>Object.assign()方法的用处:</p><ul><li>为对象添加属性</li><li>为对象添加方法</li><li>克隆对象</li><li>合并多个对象</li><li>为属性指定默认值</li></ul><p>ECMAScript6属性的遍历方法:</p><ul><li>for..in循环遍历对象自身和继承的可枚举属性(不含Symbol属性)</li><li>Object.keys(obj)方法返回一个数组, 包含对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)</li><li>Object.getOwnPropertyNames(obj)方法返回一个数组, 包含对象自身的所有属性(包含不可枚举属性, 不含Symbol属性)</li><li>Object.getOwnPropertySymbols(obj)方法返回一个数组, 包含对象自身的所有Symbol属性</li><li>Reflect.ownKeys(obj)方法返回一个数组, 包含对象自身的所有属性, 不管是属性名是Symbol或字符串, 也不管是否可枚举</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMAScript5对象属性名都是字符串, 容易造成属性名的冲突</span></span><br><span class="line"><span class="comment">// 为了防止属性名的冲突, ECMAScript6引入了Symbol</span></span><br><span class="line"><span class="comment">// Symbol值作为对象属性名时, 不能用点运算符</span></span><br><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> bar = &#123;&#125;;</span><br><span class="line">bar.mySymbol = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar[mySymbol]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(bar[<span class="string">'mySymbol'</span>]); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>点运算符后面总是字符串, 所以不会读取mySymbol作为标识符所指代的那个值, 导致bar的属性名实际上是一个字符串, 而不是一个Symbol的值.</p><p>Symbol作为属性名, 该属性不出现在for..in, for..of循环中, 也不会被Object.keys()方法和Object.getOwnPropertyNames()方法返回. 但是他也不是私有属性, Object.getOwnPropertySymbols()方法可以获取指定对象的所有Symbol属性名.</p><p>Reflect.ownKeys()方法可以返回所有类型的键名, 包括常规键名和Symbol键名.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'obj_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">  foo: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj); <span class="comment">// [Symbol(obj_key), 'bar', 'foo']</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol.for()方法可以重新使用同一个Symbol的值</span></span><br><span class="line"><span class="comment">// 它接收一个字符串作为参数, 搜索有没有以该参数作为名称的Symbol值</span></span><br><span class="line"><span class="comment">// 如果搜索有这个值, 返回这个Symbol值</span></span><br><span class="line"><span class="comment">// 否则就新建并返回一个以该字符串为名称的Symbol值</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> symOne = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(symOne); <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">var</span> symTwo = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(symTwo); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h4><p>ECMAScript6提供了新的数据结构Set. 它类似数组, 但元素值都是唯一的, 无重复值. Set本身是一个构造函数, 可以用来生成Set数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>].map(<span class="function"><span class="params">a</span> =&gt;</span> bar.add(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> bar) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 2 5 6 1</span></span><br></pre></td></tr></table></figure><p>Set实例对象的属性和方法</p><ul><li>Set.prototype.constructor属性: 构造函数, 默认是Set函数</li><li>Set.prototype.size属性: 返回Set实例对象的成员总数</li><li>add(value)方法: 添加某个值, 返回Set结构本身</li><li>delete(value)方法: 删除某个值, 返回一个布尔值, 表示删除是否成功</li><li>has(value)方法: 返回一个布尔值, 表示该值是否为Set的成员</li><li>clear()方法: 清除所有成员, 没有返回值</li></ul><p>JavaScript对象本质上是键值对的集合(Hash结构), 传统上只能用字符串当作键, 给使用带来了限制. 为了解决这个问题, ECMAScript6提供了Map数据结构, 它类似对象, 也是键值对的集合, 但是”键”的范围不限于字符串, 各种类型的值(包括对象)都可以当作键.</p><p>原生Map提供三个遍历器生成函数和一个遍历方法</p><ul><li>keys(): 返回键名的遍历器</li><li>values(): 返回键值的遍历器</li><li>entries(): 返回所有成员的遍历器</li><li>forEach(): 遍历Map的所有成员</li></ul><h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>Generator函数从语法上可以把它理解成是一个状态机, 封装了多个内部状态. 执行Generator函数会返回一个遍历器对象, 他除了状态机, 还是一个遍历器对象生成函数, 返回的遍历器对象, 可以一次遍历Generator函数内部的每一个状态.</p><p>Generator函数形式上是一个普通函数, 但有两个特点, function关键字与函数名之间有一个星号, 函数体内部使用yield语句定义不同的内部状态.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Gener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = Gener();</span><br><span class="line">foo.next(); <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">foo.next(); <span class="comment">// &#123; value: 'world', done: fasle &#125;</span></span><br><span class="line">foo.next(); <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">foo.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h4 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* success */</span>) &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise实例对象可以使用then()方法分别指定Resolved状态和Reject状态的回调函数. then()方法可以接收两个回调函数作为参数. 第一个回调函数是Promise对象的状态变为Resolved时调用, 第二个回调函数是Promise对象的状态变为Reject时调用. 第二个回调函数是可选的, 不一定要提供, 这两个回调函数都可以接收Promise对象传出的值作为参数. then()方法返回的是一个新的Promise实例(不是原来的Promise实例), 我们可以使用链式写法, 即then()方法之后再调用另一个then()方法.</p><p>Promise实例对象的catch()方法, 也就是<code>.then(null, rejection)</code>的别名, 用于指定发生错误时的回调函数. 不要在then()方法里面定义Reject状态的回调函数(即then()方法的第二个参数), 而是使用catch()方法.</p><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.a + <span class="string">', '</span> + <span class="keyword">this</span>.b + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了一个”类”, 里面有一个constructor()方法, 这就是构造函数, this关键字代表实例对象. 由于类的方法默认定义在prototype对象上面, 所以类的新方法可以添加在prototype对象上面. Object.assign()方法可以很方便一次向类添加多个方法.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Person.prototype, &#123;</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>类内部所有定义的方法都是不可枚举的(non-enumerable).</p></blockquote><p>constructor()方法是类的默认方法, 通过new关键字创建实例对象时, 自动调用该方法. 一个类必须有constructor()方法, 如果没有显示定义, 会默认添加一个空的constructor()方法. contructor()方法默认返回的实例对象(即this)可以指定返回另一个对象.</p><h4 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class之间可以使用extends关键字实现继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类构造函数中, 只有调用super()方法之后, 才可以使用this关键字, 否则会报错</span></span><br><span class="line"><span class="comment">// Class不存在变量提升</span></span><br><span class="line"><span class="keyword">new</span> Person(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Object.getPrototypeOf()方法可以从子类上获取父类, 可以使用该方法判断一个类是否继承至另一个类</p></blockquote><p>super关键字</p><ul><li>作为函数调用时(即super(…args)), super代表父类的构造函数</li><li>作为对象调用时(即super.prop或者super.method()), super代表父类, 此时super既可以引用父类实例的属性和方法, 也可以引用父类的静态方法</li></ul><p>Class静态方法</p><p>类相当于实例的原型, 所有在类中定义的方法, 都会被实例继承. 在一个方法前加上static关键字, 表示该方法不会被实例继承, 而是直接通过类来调用, 这被称为<code>静态方法</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ECMAScript6.0(简称ES6)是JavaScript语言的下一代标准, 已经在2015年6月正式发布了. 它的目标是使JavaScript可以用来编写复杂的大型应用程序, 成为企业级开发语言. 各个浏览器对ECMAScript6的支持可以查看 &lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>OOP in JavaScript</title>
    <link href="https://yieeo.github.io/2018/04/10/JavaScript-OOP/"/>
    <id>https://yieeo.github.io/2018/04/10/JavaScript-OOP/</id>
    <published>2018-04-10T09:44:54.000Z</published>
    <updated>2018-12-20T12:46:22.846Z</updated>
    
    <content type="html"><![CDATA[<p>对象和类是面向对象的基础, 封装, 继承和多态是面向对象编程(OOP)的三大特性.</p><p>JavaScript提供了对象却缺乏类, 他不能和Java等语言一样显式的定义一个类. 但是JavaScript函数功能非常灵活, 我们可以使用构造函数和原型对象来实现类.</p><h4 id="对象和类的概念"><a href="#对象和类的概念" class="headerlink" title="对象和类的概念"></a>对象和类的概念</h4><p>对象是面向对象编程中非常重要的一个概念, 一个对象是一个东西(某个人或者某件事)的描述.<br>对象包含特征和行为, 用OOP的术语来说, 特征是对象的属性, 行为是对象的方法.</p><p>类相当于一个模板, 基于这个模板可以创建不同的具体对象.</p><blockquote><p>在JavaScript中一切都是基于对象的, 原型也是对象, JavaScript的继承和重用也是通过原型实现的.</p></blockquote><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>我们可以使用<code>new Array()</code>创建一个数组, 使用<code>new Object()</code>创建一个对象. <code>Array()</code>和<code>Object()</code>是JavaScript内置的两个构造函数, 尽管JavaScript没有提供类, 我们可以将Array和Object理解为”类”的概念.</p><p>构造函数也是函数, 定义构造函数和其它函数并没有语法上的区别. 唯一的区别就是构造函数的首字母应该大写, 这也是JavaScript的编程规范.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Person()构造函数, 我们可以将它理解为Person类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为Person类添加属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Mary'</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">this</span>.sex = <span class="string">'male'</span>;</span><br><span class="line">  <span class="comment">// 为Person类添加方法</span></span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'believe in youself'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Person()构造函数创建实例对象</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><blockquote><p>foo实例对象和bar实例对象都是通过Person构造函数创建出来的, 但是修改其中一个的实例对象的属性和方法并不会影响的另一个实例对象的属性和方法.</p></blockquote><h4 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h4><p>当创建一个对象时, 一个特殊的属性就被JavaScript自动分配给这个对象了, 这个属性就是constructor属性. 当访问某个对象的constructor属性时, 就会返回创建这个对象的构造函数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Mary'</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">this</span>.sex = <span class="string">'male'</span>;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'believe in youself'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bingo = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(bingo.constructor); <span class="comment">// 返回构造函数Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.constructor); <span class="comment">// 返回内置的构造函数Object</span></span><br></pre></td></tr></table></figure><h4 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h4><p>在JavaScript中定义一个函数, 这个函数就会拥有prototype属性, 构造函数也不例外.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Mary'</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">this</span>.sex = <span class="string">'male'</span>;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'believe in youself'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(bingo.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>构造函数Person的prototype属性是一个对象, 他是属于函数的, 我们称这个属性为原型对象. 从Person类的角度出发, 可以理解为prototype属性是属于Person类的. 同时Person类的实例对象是没有prototype属性的, 上面代码中的<code>bingo.prototype</code>是<code>undefined</code>, 说明prototype属性是共享的.</p></blockquote><p>既然实例对象的prototype属性是一个对象, 那么我们就可以给这个对象添加属性和方法.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'believe in youself'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构造函数Person的prototype属性上添加属性和方法</span></span><br><span class="line"><span class="comment">// 在Person.prototype属性上定义的属性和方法可以直接被Person类的实例对象使用</span></span><br><span class="line">Person.prototype.hobby = <span class="string">'swim'</span>;</span><br><span class="line">Person.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'is run in the park'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person(<span class="string">'Mary'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.run());</span><br></pre></td></tr></table></figure><blockquote><p>我们可以通过<code>hasOwnPrototype</code>方法查看对象是否包含某个属性或方法.</p></blockquote><h4 id="类的实现总结"><a href="#类的实现总结" class="headerlink" title="类的实现总结"></a>类的实现总结</h4><ul><li>JavaScript没有类,但是构造函数可以实现类</li><li>按照JavaScript编程规范,构造函数的首字母应该大写</li><li>在创建对象时,JavaScript为这个对象分配了一个<code>constructor</code>属性,<code>constructor</code>属性是对象构造函数的引用</li><li>函数在定义时拥有了<code>prototype</code>属性,<code>prototype</code>属性也是一个对象</li><li>prototype属性上的属性和方法是共享的,定义在<code>prototype</code>属性的属性和方法可以被类的实例对象使用</li><li>如果属性或者方法能够定义在<code>prototype</code>属性上,就不要定义在构造函数中,使用<code>prototype</code>可以减少内存开销</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象和类是面向对象的基础, 封装, 继承和多态是面向对象编程(OOP)的三大特性.&lt;/p&gt;
&lt;p&gt;JavaScript提供了对象却缺乏类, 他不能和Java等语言一样显式的定义一个类. 但是JavaScript函数功能非常灵活, 我们可以使用构造函数和原型对象来实现类.&lt;/
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript RegExp Object</title>
    <link href="https://yieeo.github.io/2018/03/21/JavaScript-RegExp/"/>
    <id>https://yieeo.github.io/2018/03/21/JavaScript-RegExp/</id>
    <published>2018-03-21T06:33:28.000Z</published>
    <updated>2018-12-04T15:07:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="创建正则对象"><a href="#创建正则对象" class="headerlink" title="创建正则对象"></a>创建正则对象</h4><p>构建函数RegExp创建正则对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = new RegExp(&apos;i$&apos;); // reg匹配以i字母结尾的字符串</span><br></pre></td></tr></table></figure><p>使用正则字面量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /i$/;</span><br></pre></td></tr></table></figure><h4 id="正则表达式字符"><a href="#正则表达式字符" class="headerlink" title="正则表达式字符"></a>正则表达式字符</h4><p>反斜杠<code>\</code>在正则表达式中表示转义序列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">特殊符号:</span><br><span class="line">^ $ . * + ? = ! | \ / ( ) [ ] &#123; &#125;</span><br></pre></td></tr></table></figure><p>如果要在正则表达式中匹配特殊符号, 就应该在特殊符号前面的加上反斜杠<code>\</code>进行转义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\$/; // reg匹配$符号</span><br></pre></td></tr></table></figure><p>字面量字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------ </span><br><span class="line">    字符   |   匹配                                               </span><br><span class="line">------------------------------------------------------------------ </span><br><span class="line">   \o      |   NUL字符(\u0000)                                   </span><br><span class="line">   \t      |   制表符(\u0009)                                    </span><br><span class="line">   \n      |   换行符(\u000A)                                    </span><br><span class="line">   \v      |   垂直制表符(\u000B)                                </span><br><span class="line">   \f      |   换页符                                            </span><br><span class="line">   \r      |   回车符                                            </span><br><span class="line">   \xnn    |   十六进制数nn指定拉丁字符, 如: \x0A等同于\n         </span><br><span class="line">   \uxxxx  |   十六进制xxxx指定的Unicode字符, 如: \u0009等同于\t  </span><br><span class="line">------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span><br><span class="line">     字符         |    匹配</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">  [...]           |    中括号内的任意字符</span><br><span class="line">  [^...]          |    非中括号内的任意字符</span><br><span class="line">  [0-9]           |    0-9之间的数字</span><br><span class="line">  [a-z]           |    小写拉丁字母</span><br><span class="line">  [A-Z]           |    大写拉丁字母</span><br><span class="line">  [ 0-9a-zA-Z ]   |    数字和大小写拉丁字母</span><br><span class="line">  .               |    除换行符和其它Unicode行终止符之外的任意字符</span><br><span class="line">  \s              |    任意Unicode空白符</span><br><span class="line">  \S              |    任意非Unicode空白符</span><br><span class="line">  \d              |    任意ASCII码数字, 等同于[0-9]</span><br><span class="line">  \D              |    任意非ASCII码数字字符, 等同于[^0-9]</span><br><span class="line">  \w              |    等同于[a-zA-Z0-9_]</span><br><span class="line">  \W              |    等同于[^a-zA-Z0-9_]</span><br><span class="line">------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>贪婪的重复字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------</span><br><span class="line">      字符        |     匹配次数</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">      &#123;n,m&#125;       |     至少n次, 但不能超过m次</span><br><span class="line">      &#123;n,&#125;        |     至少n次</span><br><span class="line">      &#123;n&#125;         |     刚好n次</span><br><span class="line">      ?           |     零次或者一次, 等同于&#123;0,1&#125;</span><br><span class="line">      +           |     至少一次, 等同于&#123;1,&#125;</span><br><span class="line">      *           |     零次或者多次, 等同于&#123;0,&#125;</span><br><span class="line">------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>非贪婪的重复匹配只需要在贪婪的重复字符后面加上一个<code>?</code>, 且问好之后没有其它的表达式字符, 不然会忽略非贪婪匹配</p><p>选择,分组和引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">  字符        |  含义</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">  |           | 表示或,用于分隔选择</span><br><span class="line">  ()          | 子表达式(子模式), 引用子模式匹配结果</span><br><span class="line">  (?:)        | 子表达式(子模式), 引用子模式匹配结果, 匹配结果不显示在正则匹配结果中</span><br><span class="line">  \n(n为数字)  | 引用对应的子模式匹配结果</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>位置字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------</span><br><span class="line">  字符   |  含义</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">  ^      |  字符串的开头</span><br><span class="line">  $      |  字符串的结尾</span><br><span class="line">  \b     |  位于\w和\W的边界或者位于一个ASCII单词字符与一个字符串开头和结尾之间的边界</span><br><span class="line">  \B     |  非词语之间的位置</span><br><span class="line">  (?=p)  |  正前向声明, 要求接下来的字符与模式p匹配,但不包括匹配中的字符</span><br><span class="line">  (?!p)  |  反前向声明, 要求接下来的字符不与模式p匹配</span><br><span class="line">--------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="正则对象标志-属性和方法"><a href="#正则对象标志-属性和方法" class="headerlink" title="正则对象标志, 属性和方法"></a>正则对象标志, 属性和方法</h4><p>标志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------------------------------</span><br><span class="line">         标志          |        含义</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">         g             |        全局匹配</span><br><span class="line">         i             |        不区分大小写</span><br><span class="line">         m             |        多行匹配</span><br><span class="line">-----------------------------------------------------</span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------</span><br><span class="line">  方法    |   含义</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">  exec    |   接收一个字符串参数, 返回由完全匹配和子表达式匹配结果组成的数组</span><br><span class="line">  test    |   接收一个字符串参数, 返回boolean值</span><br><span class="line">  compile |   编译正则表达式</span><br><span class="line">-------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------</span><br><span class="line">  属性       |    含义</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">  sourse     |    正则表达式的文本</span><br><span class="line">  global     |    是否拥有全局搜索标志g</span><br><span class="line">  ignoreCase |    是否拥有标志i</span><br><span class="line">  multiline  |    是否拥有标志m</span><br><span class="line">  lastIndex  |    搜索匹配的开始位置(可读写)</span><br><span class="line">-------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;创建正则对象&quot;&gt;&lt;a href=&quot;#创建正则对象&quot; class=&quot;headerlink&quot; title=&quot;创建正则对象&quot;&gt;&lt;/a&gt;创建正则对象&lt;/h4&gt;&lt;p&gt;构建函数RegExp创建正则对象&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Function Closures</title>
    <link href="https://yieeo.github.io/2018/02/18/JavaScript-closures/"/>
    <id>https://yieeo.github.io/2018/02/18/JavaScript-closures/</id>
    <published>2018-02-18T10:15:32.000Z</published>
    <updated>2018-12-04T15:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方对闭包的解释: 一个拥有许多变量和绑定这些变量的环境的表达式(通常是一个函数)</p></blockquote><h4 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h4><ul><li>作为一个函数变量的一个引用, 当函数返回时, 其处于激活状态</li><li>一个闭包就是当一个函数返回时, 一个没有释放资源的栈区</li></ul><p>简单理解,JavaScript允许使用内部函数, 即函数定义和函数表达式位于另一个函数的函数体内. 而且, 这些内部函数可以访问它们所在的外部函数中声明的所有局部变量和参数以及声明的其它内部函数. 当其中一个这样的内部函数在包含它们的外部函数被调用时, 就会形成闭包.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'the power of imagination makes us infinite'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = closure();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>上述代码, 变量bar定义在函数closure中, 属于局部变量. 若变量bar在closure函数调用完成以后不能再被访问, 在函数执行完成后变量bar将被释放. 但是由于函数closure返回一个内部函数, 而且返回函数引用了变量bar, 导致了变量bar可能会在closure函数执行完成以后还会被引用, 所以变量bar占用的资源不会回收, 这时函数closure就形成一个闭包.</p><blockquote><p>JavaScript垃圾回收(GC)的原则是: 如果一个对象不再被引用,那么这个对象会被垃圾回收器回收. 如果两个对象无干扰的互相引用, 那么则两个对象也会被回收.</p></blockquote><h4 id="为执行的函数提供参数"><a href="#为执行的函数提供参数" class="headerlink" title="为执行的函数提供参数"></a>为执行的函数提供参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeout()方法可以延迟执行某个函数</span></span><br><span class="line"><span class="comment">// 第一个参数是需要执行的函数或者代码</span></span><br><span class="line"><span class="comment">// 第二个参数是延迟的毫秒数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'life is not lack of beauty, just missing a pair of eyes to find beauty'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(say(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在setTimeout方法中我们无法给需要的延迟执行的函数传递参数</span></span><br><span class="line"><span class="comment">// 使用闭包我们这样做</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(say(<span class="string">'there is no end to learning'</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h4 id="模拟静态私有变量"><a href="#模拟静态私有变量" class="headerlink" title="模拟静态私有变量"></a>模拟静态私有变量</h4><blockquote><p>JavaScript本身不支持面向对象(OOP)的特性. 但是我们可以通过JavaScript的一些特性模拟实现JavaScript面向对象.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类, 模拟静态私有变量</span></span><br><span class="line"><span class="keyword">var</span> ClassPerson = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>; <span class="comment">// 静态私有变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getA()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(bingo.getA()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>在上面的例子中, 使用变量a记录ClassPerson被实例化的次数, 使用闭包将变量a模拟为静态私有变量, 每次ClassPerson被实例化时将变量a的值加一. 定义在外层函数内或者内层函数外的成员类似静态成员. 这种形式的代码称作<code>静态封装环境</code>.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方对闭包的解释: 一个拥有许多变量和绑定这些变量的环境的表达式(通常是一个函数)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;闭包的特点&quot;&gt;&lt;a href=&quot;#闭包的特点&quot; class=&quot;headerlink&quot; title=&quot;闭包的特点&quot;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript this Keyword</title>
    <link href="https://yieeo.github.io/2018/01/19/JavaScript-this/"/>
    <id>https://yieeo.github.io/2018/01/19/JavaScript-this/</id>
    <published>2018-01-19T12:56:14.000Z</published>
    <updated>2018-12-04T15:06:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在执行上下文的创建阶段, 会分别生成变量对象, 建立作用域链, 确定this指向. this指向是在函数被调用的时候确定的, 也就是执行上下文被创建时确定的. 一个函数中的this指向可以非常灵活.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 4</span></span><br><span class="line">foo.call(obj); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><blockquote><p>在函数执行过程中, this一旦被确定, 就不可更改.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span> = obj; <span class="comment">// 试图修改this, 运行时会报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h4 id="全局对象中的this"><a href="#全局对象中的this" class="headerlink" title="全局对象中的this"></a>全局对象中的this</h4><blockquote><p>全局对象对象中的this, 指向它本身.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过this绑定到全局对象</span></span><br><span class="line"><span class="keyword">this</span>.a = <span class="string">'zero'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过声明绑定到变量对象, 全局环境中变量对象就是它本身</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'one'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值操作, 标识符会隐式绑定到全局对象</span></span><br><span class="line">c = <span class="string">'two'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印日志</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure><h4 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the first demo</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the second demo</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the third demo</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">50</span>,</span><br><span class="line">  b: <span class="keyword">this</span>.a + <span class="number">10</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b);</span><br><span class="line"><span class="built_in">console</span>.log(obj.foo());</span><br></pre></td></tr></table></figure><p>想要准确确定this指向, 找到函数的调用者以及区分它是否独立调用就变得十分关键. 在一个函数上下文中, this由调用者提供, 由调用函数的方式来决定. 如果调用者函数被某一个对象所拥有, 那么该函数在调用时, 内部的this指向该对象, 如果函数独立调用, 那么该函数内部的this, 则指向undefined. 但在非严格模式中, this指向undefined时, 它会被自动指向全局对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式this会自动指向全局, 我们在函数内部使用严格模式获得更准确的判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// bar是调用者, 独立调用</span></span><br><span class="line"><span class="built_in">window</span>.bar(); <span class="comment">// bar是调用者, 被window对象所拥有</span></span><br></pre></td></tr></table></figure><p>在上面的例子中, <code>bar()</code>作为独立调用者, 按照定义的理解, 它内部的this指向<code>undefined</code>. 而<code>window.bar()</code>因为fn()方法被window对象所拥有, 内部的this指向window对象.</p><p>在<code>the third demo</code>中, 对象obj的b属性使用<code>this.a + 10</code>来计算. 单独的<code>{}</code>不会形成新的作用域的, 因此这里的<code>this.a</code>, 由于没有作用域的限制, 它仍处于全局作用域中, 所以这里的this其实指向的是window对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bar()); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = foo.bar();</span><br><span class="line"><span class="built_in">console</span>.log(bingo()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><code>foo.bar()</code>中, bar是调用者, 它不是独立调用, 被对象foo所拥有, 因此它的this指向foo. 而<code>bingo()</code>作为调用者, 尽管它与foo.bar的引用相同, 但是它是独立调用的, 因此this指向undefined, 在非严格模式中, 自动指向window全局对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 稍微修改一下代码</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: bar</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bar()); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次修改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bingo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn(); <span class="comment">// 独立调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bingo(obj.bar); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h4 id="call-apply显式指定this指向"><a href="#call-apply显式指定this指向" class="headerlink" title="call,apply显式指定this指向"></a>call,apply显式指定this指向</h4><p>JavaScript内部给我们提供两种方法<code>call()</code>和<code>apply()</code>, 可以手动设置this的指向. 所有函数都具有这两个方法, 除了参数略有不同, 实现功能完全一样.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// bar并不是obj的方法, 通过call方法, 将bar内部的this指向obj对象</span></span><br><span class="line"><span class="comment">// 通过this.a访问obj的a属性</span></span><br><span class="line">bar.call(obj); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.c + a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// call()方法和apply()方法的参数:</span></span><br><span class="line"><span class="comment">// 第一个参数为this将要指向的对象</span></span><br><span class="line"><span class="comment">// 第二个参数call()方法是以单个的方式传递, apply()是以数组的方式传递</span></span><br><span class="line">bar.call(obj, <span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 18</span></span><br><span class="line">bar.apply(obj,[<span class="number">10</span>,<span class="number">5</span>]); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将类数组对象转换为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 使用call/apply将arguments转为数组, 返回数组, arguments不会改变</span></span><br><span class="line">  <span class="keyword">var</span> arg = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;</span><br><span class="line">example(<span class="string">'zero'</span>,<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改this指向</span></span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  name: <span class="string">'joker'</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'say hello world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  name: <span class="string">'knight'</span></span><br><span class="line">&#125;;</span><br><span class="line">bar.say.call(foo);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.sex = [<span class="string">'male,female'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Son = <span class="function"><span class="keyword">function</span> (<span class="params">name, age, hobby</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">  <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype.message = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'name: '</span> + <span class="keyword">this</span>.name + <span class="string">', age: '</span> + <span class="keyword">this</span>.age + <span class="string">', sex: '</span> + <span class="keyword">this</span>.sex + <span class="string">', hobby: '</span> + <span class="keyword">this</span>.hobby);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Son(<span class="string">'Mike'</span>, <span class="number">18</span>, <span class="string">'swim'</span>).message();</span><br></pre></td></tr></table></figure><p>在Son构造函数中使用call()方法将父级构造函数执行了一次, 相当于将Person中的代码在Son构造函数复制了一份, this指向为Son构造函数new出来的实例对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Son = <span class="function"><span class="keyword">function</span> (<span class="params">name, age, hobby</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.sex = [<span class="string">'male'</span>,<span class="string">'female'</span>];</span><br><span class="line">  <span class="comment">// Person.call(this, name, age); 相当于执行了上面三行代码</span></span><br><span class="line">  <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在向其它执行上下文的传递中, 确保this指向保持不变</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们希望bar()方法被obj对象调用时, this指向obj对象</span></span><br><span class="line"><span class="comment">// 但是匿名函数导致this指向丢失, 在匿名函数中this指向了全局</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(fucntion () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改上面代码</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将this的引用保存起来, 赋值给that变量</span></span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    setTimeout(fucntion () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that.a);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.bar();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装bind()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(bind(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;, <span class="keyword">this</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ES5中的bind()方法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">8</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构造函数与原型方法上的this"><a href="#构造函数与原型方法上的this" class="headerlink" title="构造函数与原型方法上的this"></a>构造函数与原型方法上的this</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">40</span>);</span><br><span class="line">bingo.foo();</span><br></pre></td></tr></table></figure><p>new操作符调用构造函数会经历是个阶段:</p><ul><li>创建一个新对象</li><li>构造函数的this指向这个新对象</li><li>指向构造函数的代码, 为这个对象添加属性和方法</li><li>返回新对象</li></ul><p>new操作符调用构造函数, this指向这个新建的对象, 然后将新对象返回, 被实例对象<code>bingo</code>接收.</p><p>原型方法上的this, 根据上面例子函数中的this定义, <code>bingo.foo()</code>中的foo为调用者, 它被bingo对象所拥有, foo中的this指向bingo对象.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在执行上下文的创建阶段, 会分别生成变量对象, 建立作用域链, 确定this指向. this指向是在函数被调用的时候确定的, 也就是执行上下文被创建时确定的. 一个函数中的this指向可以非常灵活.&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Scope</title>
    <link href="https://yieeo.github.io/2018/01/08/JavaScript-scope/"/>
    <id>https://yieeo.github.io/2018/01/08/JavaScript-scope/</id>
    <published>2018-01-08T05:26:14.000Z</published>
    <updated>2018-12-04T15:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作用域是一套用于确定在何处以及如何查找变量的规则. 赋值操作会导致LHS查询, 获取变量值的操作会导致RHS查询. 引擎在处理代码时会优化处理变量声明和函数声明, 这种机制叫做提升.</p></blockquote><h4 id="JavaScript编译原理"><a href="#JavaScript编译原理" class="headerlink" title="JavaScript编译原理"></a>JavaScript编译原理</h4><p>在传统的编译语言流程中, 程序的执行会经过三个步骤, 我们称这个过程为编译</p><ul><li>分词: 词法分析(将字符串分解成有意义的代码块)</li><li>解析: 语法分析(将词法单元转换成一个由元素逐级嵌套代表的程序语法结构的树)</li><li>代码生成(将上面生成的树转换为可执行的代码)</li></ul><p>JavaScript是属于解释性语言, 但是代码的编译过程与上面类似, 现在浏览器执行JavaScript代码非常快速, 一般编译过程发生在代码运行前的一瞬间.</p><h4 id="scope-作用域"><a href="#scope-作用域" class="headerlink" title="scope(作用域)"></a>scope(作用域)</h4><p>作用域负责收集和维护由所有变量组成的查询, 并且确定一套规则来判断当前代码对这些变量的访问权限.</p><p>对于<code>var foo = 0;</code>来说, 编译器首先在当前作用域声明一个变量foo, 之后在运行时JS引擎会从当前作用域中查找变量foo, 再然后将数字0赋值给变量foo.</p><h4 id="scope-chain-作用域链"><a href="#scope-chain-作用域链" class="headerlink" title="scope chain(作用域链)"></a>scope chain(作用域链)</h4><p>每一个函数都有自己的执行环境, 当函数嵌套在另一个函数或块中, 就会形成作用域链. 作用域链的前端就是当前执行环境, 全局执行环境的变量即作用域链的顶端. 在当前作用域中找不到变量时, JS引擎会沿着作用域链一级一级向上查询, 直到找到为止.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>上面的例子中, foo的作用域中没有变量a, 需要使用变量a需要向上一级查找.</p><h4 id="LHS-and-RHS"><a href="#LHS-and-RHS" class="headerlink" title="LHS and RHS"></a>LHS and RHS</h4><p>JS引擎进行变量查询的方式有两种, 分别是LHS和RHS. LHS表示查询赋值操作的目标, RHS表示查询赋值操作的源头. 简单的说, LHS查询是寻找这个变量的容器本身, 从而进行赋值操作, RHS查询是查找某个变量的值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>对上面的例子进行分析:</p><ul><li>要执行函数foo, 需要知道其赋值操作的源头, 从而进行RHS引用</li><li>接下来把数字1赋值给函数foo的形参a, 需要进行一次LHS引用, 这是一个隐式变量分配</li><li>对console进行RHS引用, console是一个内置对象, 有log()方法</li><li>确认形参a的值, 进行一次RHS查询, 将形参a的值传递给console对象的log()方法</li></ul><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>如果RHS查询在所有的作用域链都没有找到所需的变量时, JS引擎就会抛出ReferenceError异常. 如果RHS查询到目标变量, 但尝试进行非法操作时, JS引擎会抛出TypeError异常.</p><p>如果LHS查询在所有的作用域链中都找不到所需的变量时, 就会在全局作用域中创建该变量并返还给JS引擎.</p><blockquote><p>注意: 严格模式中禁止自动或隐式创建变量,LHS查询失败时同样会返回ReferenceError异常.</p></blockquote><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p>作用域一般有两种工作模式, 一种是为大多数语言使用的词法作用域, 另一种是动态作用域.</p><p>词法作用域就是定义在词法阶段的作用域. 词法作用域是由书写代码是函数声明位置决定的. 作用域一旦确定基本上会保持不变. 当然也有欺骗词法的方法, 但不推荐使用, 欺骗作用域会导致性能下降.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域, 只有foo标识符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">m</span>) </span>&#123; <span class="comment">// foo的作用域, m, n和bar三个标识符</span></span><br><span class="line">  <span class="keyword">var</span> n = m - <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123; <span class="comment">// bar的作用域, 只有x标识符</span></span><br><span class="line">    <span class="built_in">console</span>.log(m, n, x);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(n + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="欺骗词法-eval"><a href="#欺骗词法-eval" class="headerlink" title="欺骗词法-eval"></a>欺骗词法-eval</h4><p>eval()方法会接收一个字符串作为参数, 并将字符串视作代码片段进行执行.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">str,a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="string">'var b = 4'</span>, <span class="number">2</span>); <span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure><blockquote><p>严格模式下, eval()方法创建的变量不能被调用.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">str, a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="string">'var b = 4'</span>, <span class="number">2</span>); <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>使用eval()方法生成代码将造成性能上的损失, 不推荐使用.</p></blockquote><h4 id="欺骗词法-with"><a href="#欺骗词法-with" class="headerlink" title="欺骗词法-with"></a>欺骗词法-with</h4><p>with()方法会将一个对象的引用当作作用域来处理, 将对象的属性当作作用域的标识符来处理, 从而创建一个新的作用域. 这种方法也会使JS引擎在编译时无法对作用域进行优化, 从而造成性能上的损失.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'one'</span>,</span><br><span class="line">  b: <span class="string">'two'</span>,</span><br><span class="line">  c: <span class="string">'three'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">  a = <span class="string">'four'</span>,</span><br><span class="line">  b = <span class="string">'five'</span>,</span><br><span class="line">  c = <span class="string">'seven'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>严格模式中with()方法被完全禁止.</p></blockquote><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><blockquote><p>属于这个函数的全部变量可以在整个函数内部或其嵌套的作用域内部使用, 这即是函数的作用域.</p></blockquote><p>1.隐藏内部实现</p><p>函数作用域可以将声明在该函数内部的变量或函数隐藏起来, 从而实现良好的设计模式. 在模块和对象的API设计中, 这种方法很常见也很实用.</p><p>下面是利用对象全局命名空间来规避冲突的方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameSpace = &#123;</span><br><span class="line">  doSomeThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  doAnotherThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.立即执行函数表达式(IIFE)</p><p>我们希望函数不需要函数名或者函数名不会污染所在的作用域, 并且能够自动执行. 这是我们可以使用IIFE来实现.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  a: <span class="string">'zero'</span>,</span><br><span class="line">  b: <span class="string">'one'</span>,</span><br><span class="line">  c: <span class="string">'two'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">global</span>) </span>&#123; <span class="comment">// 将bar对象的引用传递进去, 参数命名为global</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'three'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// three</span></span><br><span class="line">  <span class="built_in">console</span>.log(global.a); <span class="comment">// zero</span></span><br><span class="line">&#125;)(bar);</span><br></pre></td></tr></table></figure><h4 id="块作用域-try-catch"><a href="#块作用域-try-catch" class="headerlink" title="块作用域(try..catch)"></a>块作用域(try..catch)</h4><p>ES3中规定try..catch会创建一个块级作用域, 其中声明的变量仅在catch内部有效.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 正常执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(err); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><h4 id="块作用域-let"><a href="#块作用域-let" class="headerlink" title="块作用域-let"></a>块作用域-let</h4><p>ES6中引用了let关键字, 可以将变量绑定到任意的作用域中. let将其声明的变量隐式的放到了它所在的块作用域中.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 正常执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用&#123;..&#125;显式声明变量</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><h4 id="块作用域-const"><a href="#块作用域-const" class="headerlink" title="块作用域-const"></a>块作用域-const</h4><p>ES6中引入了const关键字, 用来声明常量. 同样可以用来创建块作用域.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">9</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><blockquote><p>声明在这个作用域中的变量都将作用在这个作用域中.</p></blockquote><h4 id="函数和变量提升"><a href="#函数和变量提升" class="headerlink" title="函数和变量提升"></a>函数和变量提升</h4><p>作用域中的声明将在代码本身执行之前首先处理, 将这个过程想象成所用声明(变量和函数)都会被移动到各自作用域的前端, 这个过程称为提升.</p><blockquote><p>先有声明后有赋值.只有函数和变量会进行提升</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码, 编译器会把声明var a; 提升到全局顶部首先进行处理, 即按照如下顺序处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有声明本身会被提升, 赋值和其它逻辑语句会停留在原地</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器把var a = 0; 视为两部分, 即var a;和a = 0;</span></span><br><span class="line"><span class="comment">// 将var a;提升到全局顶部, 首先进行处理, 赋值操作a = 0; 留在原地.</span></span><br><span class="line"><span class="comment">// 编译器会按照如下形式处理这段代码:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个作用域只会在自己的作用域范围内进行提升</span></span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码块中, 全局作用域中的函数声明会被提升, bar函数作用域中的var a;也会被提升</span></span><br><span class="line"><span class="comment">// 即按照下面的顺序进行处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><blockquote><p>函数首先会被提升, 然后才是变量. 要避免重复声明, 当变量声明和函数声明混合在一起容易造成混乱.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作用域是一套用于确定在何处以及如何查找变量的规则. 赋值操作会导致LHS查询, 获取变量值的操作会导致RHS查询. 引擎在处理代码时会优化处理变量声明和函数声明, 这种机制叫做提升.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;JavaSc
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>The History Of JavaScript</title>
    <link href="https://yieeo.github.io/2017/11/21/JavaScript-history/"/>
    <id>https://yieeo.github.io/2017/11/21/JavaScript-history/</id>
    <published>2017-11-20T23:53:54.000Z</published>
    <updated>2018-12-04T15:07:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是由Netscape Communications Corporation(网景公司)程序员Brendan Eich(布兰登.艾克)于1995年创造出来的. Eich只用了10天就开发出了这门脚本语言, 最初命名为Mocha.</p><p>1995年9月网景公司在自己的Netscape Navigator浏览器2.0中将这门语言改名为LiveScript. 同年12月, 网景公司为了将这门语言搭上Java这个编程语言”热词”, 随后又改名为JavaScript, 但是这门语言与Java没有任何关系. 随后JavaScript在浏览器上大获成功, 不久后微软公司在自己的Internet Explorer浏览器上推出了JScript, 与网景公司进行同台竞争. JScript也是一种JavaScript的实现, 这两个的语言版本的共存使得浏览器的语言标准化的缺失. 微软在自己的网页技术上加入一些的自己的专属方法, 使得网页在不同的浏览器的效果呈现出的不同的效果, 程序员写一份代码无法在不同的浏览器上呈现出相同的效果, 对于相应的浏览器必须写兼容相应浏览器的代码. 语言实现的不同专有化DOM(文档对象模型)的差异, 成为了网络上普及JavaScript的阻碍.</p><p>终于在1996年11月, 网景公司正式向ECMA(欧洲计算机制造商协会)提交语言标准. 1997年6月, ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262.ECMA标准. 流程以循环方式运行 - ECMAScript 2于1998年发布, ECMAScript 3于1999年发布(演变为今天的现代JavaScript). 尽管微软开始用JScript语言实现一些提议, 但很明显微软不会在Internet Explorer中实现JavaScript. 2005年, Eich和Mozilla加入ECMA协助E4X(ECMA-357), 与Macromedia(被Adobe收购)合作, 他们正致力于在ActionScript 3中实施E4X. 这种合作的目标是标准化AS3中的内容并在SpiderMonkey中实现它. 因此, Adobe发布了Tamarin, 一个源自AVM2的开放课程项目.</p><p>开源社区和开发者社区也在努力彻底改变JavaScript以及可以用它做些什么, 社区的影响达到了顶峰, Jesse James Garrett于2005年发布了一篇论文, 其中描述了JavaScript支持的一组技术作为支柱. 他创造了“Ajax”这个词. 该文引发了大量开发人员倾向于JavaScript以及围绕它的开源社区和库. 此外, jQuery, Prototype和Dojo是新发布的库之一. Ajax的优势使JavaScript成为人们关注的焦点, 并带来了更多专业的编程注意力. 结果是全面的框架和库的增加, 以及在Web浏览器之外增加JavaScript的使用, 正如服务器端JavaScript平台的激增.</p><p>截至2016年, 统计数据显示, 约92％的网站使用JavaScript - 其中包括一些全球最大的网站, 如Google和Facebook. 并且由于JavaScript, 使这些网站成为现实的元素是可能的. 例如, 如果没有JavaScript, 我们就不会拥有我们习以为常的实时通知. 今天, JavaScript仍然无处不在 - 它是最常用的客户端脚本语言. JavaScript被写入HTML文档, 并以许多独特的方式实现与网页的交互. 例如, 由于JavaScript, 我们可以自动安排约会和玩在线游戏. 此外, 诸如Node.js之类的新开发允许在服务器端使用JavaScript, 而诸如HTML5之类的API允许控制用户媒体和其他设备功能.</p><h4 id="JavaScript的组成部分"><a href="#JavaScript的组成部分" class="headerlink" title="JavaScript的组成部分"></a>JavaScript的组成部分</h4><ul><li>ECMAScript, 描述了该语言的语法和基本对象</li><li>DOM(文档对象模型), 描述了处理网页内容的方法和接口</li><li>BOM(浏览器对象模型), 描述了与浏览器进行交互的方法和接口</li></ul><h4 id="JavaScript的基本特点"><a href="#JavaScript的基本特点" class="headerlink" title="JavaScript的基本特点"></a>JavaScript的基本特点</h4><p>JavaScript通常缩写为JS, 是一种高级的, 解释执行的编程语言. JavaScript是一门基于原型和函数先行的语言, 是一门多范式的语言, 它支持面向对象编程, 命令式编程, 以及函数式编程. 随着最新的HTML5和CSS3语言标准的推行它还可以用于游戏, 桌面和移动应用程序的开发和在服务器端网络环境运行, 如Node.js</p><p>JavaScript由ECMA通过ECMAScript实现语言的标准化, 已经被世界上绝大多数浏览器所使用, 也被世界上的主流浏览器(Chrome, FireFox, Opera, Safari, IE)支持.</p><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>既然谈到了浏览器, 就不得不谈谈现在的主流浏览器的内核, 浏览器内核可以分为两部分: 渲染引擎和JS引擎. 最开始渲染引擎和JS引擎并没有区分的很明确, 后来JS引擎(最著名的JS引擎就是Google的V8引擎, V8引擎也促进了后来Node.js的诞生)越来越独立, 内核倾向于只指渲染引擎.</p><ul><li>Chrome浏览器内核: 统称为Chromium内核或Chrome内核, 以前是Webkit内核, 现在是Blink内核</li><li>FireFox浏览器内核: Gecko内核</li><li>Opera浏览器内核: 最初是自己的Presto内核, 后与Google一起研发内核, 使用过Webkit内核, 现在是Blink内核</li><li>Safari浏览器内核: Webkit内核</li><li>IE浏览器内核: Trident内核</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript是由Netscape Communications Corporation(网景公司)程序员Brendan Eich(布兰登.艾克)于1995年创造出来的. Eich只用了10天就开发出了这门脚本语言, 最初命名为Mocha.&lt;/p&gt;
&lt;p&gt;1995年9
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yieeo.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
