<!DOCTYPE html><html prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>JavaScript Function Closures · yie's Blog</title><meta name="description" content="JavaScript Function Closures - yie"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_1472710214_6648843.css"><link rel="stylesheet" href="//raw.githack.com/xwartz/hexo-theme-nuna/next/source/style/main.css?v=1.0.3"></head><body class="pupa"><div class="loading-bar"></div><main><div class="post post"><article itemscope itemtype="http://schema.org/Article" class="hentry"><div class="container"><div class="entry-header"><h1 class="entry-title">JavaScript Function Closures</h1><div class="entry-description"></div><div class="entry-meta"><time itemprop="datePublished" datetime="Sunday, February 18th 2018, 6:15:32 pm" class="updated">Feb 18, 2018</time><em class="post-count">1,759 words</em></div></div><div itemprop="articleBody" class="entry-content"><blockquote>
<p>官方对闭包的解释: 一个拥有许多变量和绑定这些变量的环境的表达式(通常是一个函数)</p>
</blockquote>
<h4 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h4><ul>
<li>作为一个函数变量的一个引用, 当函数返回时, 其处于激活状态</li>
<li>一个闭包就是当一个函数返回时, 一个没有释放资源的栈区</li>
</ul>
<p>简单理解,JavaScript允许使用内部函数, 即函数定义和函数表达式位于另一个函数的函数体内. 而且, 这些内部函数可以访问它们所在的外部函数中声明的所有局部变量和参数以及声明的其它内部函数. 当其中一个这样的内部函数在包含它们的外部函数被调用时, 就会形成闭包.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="string">'the power of imagination makes us infinite'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = closure();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>上述代码, 变量bar定义在函数closure中, 属于局部变量. 若变量bar在closure函数调用完成以后不能再被访问, 在函数执行完成后变量bar将被释放. 但是由于函数closure返回一个内部函数, 而且返回函数引用了变量bar, 导致了变量bar可能会在closure函数执行完成以后还会被引用, 所以变量bar占用的资源不会回收, 这时函数closure就形成一个闭包.</p>
<blockquote>
<p>JavaScript垃圾回收(GC)的原则是: 如果一个对象不再被引用,那么这个对象会被垃圾回收器回收. 如果两个对象无干扰的互相引用, 那么则两个对象也会被回收.</p>
</blockquote>
<h4 id="为执行的函数提供参数"><a href="#为执行的函数提供参数" class="headerlink" title="为执行的函数提供参数"></a>为执行的函数提供参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeout()方法可以延迟执行某个函数</span></span><br><span class="line"><span class="comment">// 第一个参数是需要执行的函数或者代码</span></span><br><span class="line"><span class="comment">// 第二个参数是延迟的毫秒数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'life is not lack of beauty, just missing a pair of eyes to find beauty'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(say(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在setTimeout方法中我们无法给需要的延迟执行的函数传递参数</span></span><br><span class="line"><span class="comment">// 使用闭包我们这样做</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(say(<span class="string">'there is no end to learning'</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h4 id="模拟静态私有变量"><a href="#模拟静态私有变量" class="headerlink" title="模拟静态私有变量"></a>模拟静态私有变量</h4><blockquote>
<p>JavaScript本身不支持面向对象(OOP)的特性. 但是我们可以通过JavaScript的一些特性模拟实现JavaScript面向对象.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类, 模拟静态私有变量</span></span><br><span class="line"><span class="keyword">var</span> ClassPerson = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>; <span class="comment">// 静态私有变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getA()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bingo = <span class="keyword">new</span> ClassPerson();</span><br><span class="line"><span class="built_in">console</span>.log(bar.getA()); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(bingo.getA()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中, 使用变量a记录ClassPerson被实例化的次数, 使用闭包将变量a模拟为静态私有变量, 每次ClassPerson被实例化时将变量a的值加一. 定义在外层函数内或者内层函数外的成员类似静态成员. 这种形式的代码称作<code>静态封装环境</code>.</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">参考链接</a></p>
</div><div class="entry-extra"><div class="entry-tags"><a href="/tags/JavaScript/" class="tag">JavaScript</a></div></div></div></article></div></main><footer><div class="copyright container"></div><!--    - var currentDate = new Date();--><!--	  - var year = currentDate.getFullYear();--><!--    - var start = config.startYear;--><!--    - year = year == start ? year : (start ? start + ' - ' + year : year);--><!--    p © Copyright #{year} by #[a(href=config.url)!= config.author].	p E-mail: yie@live.cn--></footer><script async src="//cdn.bootcss.com/mathjax/2.7.0-beta.0/MathJax.js"></script><script async src="//raw.githack.com/Easyfood/pageAccelerator/master/dist/page-accelerator.min.js"></script><script async src="/script/loading.js"></script><script async src="/script/photo.js"></script></body></html>