<!DOCTYPE html><html prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>JavaScript Scope · yie's Blog</title><meta name="description" content="JavaScript Scope - yie"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_1472710214_6648843.css"><link rel="stylesheet" href="//raw.githack.com/xwartz/hexo-theme-nuna/next/source/style/main.css?v=1.0.3"></head><body class="pupa"><div class="loading-bar"></div><main><div class="post post"><article itemscope itemtype="http://schema.org/Article" class="hentry"><div class="container"><div class="entry-header"><h1 class="entry-title">JavaScript Scope</h1><div class="entry-description"></div><div class="entry-meta"><time itemprop="datePublished" datetime="Monday, January 8th 2018, 1:26:14 pm" class="updated">Jan 8, 2018</time><em class="post-count">4,699 words</em></div></div><div itemprop="articleBody" class="entry-content"><blockquote>
<p>作用域是一套用于确定在何处以及如何查找变量的规则.赋值操作会导致LHS查询,获取变量值的操作会导致RHS查询.引擎在处理代码时会优化处理变量声明和函数声明,这种机制叫做提升.</p>
</blockquote>
<h4 id="JavaScript编译原理"><a href="#JavaScript编译原理" class="headerlink" title="JavaScript编译原理"></a>JavaScript编译原理</h4><p>在传统的编译语言流程中,程序的执行会经过三个步骤,我们称这个过程为编译</p>
<ul>
<li>分词: 词法分析(将字符串分解成有意义的代码块)</li>
<li>解析: 语法分析(将词法单元转换成一个由元素逐级嵌套代表的程序语法结构的树)</li>
<li>代码生成(将上面生成的树转换为可执行的代码)</li>
</ul>
<p>JavaScript是属于解释性语言,但是代码的编译过程与上面类似,现在浏览器执行JavaScript代码非常快速,一般编译过程发生在代码运行前的一瞬间.</p>
<h4 id="scope-作用域"><a href="#scope-作用域" class="headerlink" title="scope(作用域)"></a>scope(作用域)</h4><p>作用域负责收集和维护由所有变量组成的查询,并且确定一套规则来判断当前代码对这些变量的访问权限.</p>
<p>对于<code>var foo = 0;</code>来说,编译器首先在当前作用域声明一个变量foo,之后在运行时JS引擎会从当前作用域中查找变量foo,再然后将数字0赋值给变量foo.</p>
<h4 id="scope-chain-作用域链"><a href="#scope-chain-作用域链" class="headerlink" title="scope chain(作用域链)"></a>scope chain(作用域链)</h4><p>每一个函数都有自己的执行环境,当函数嵌套在另一个函数或块中,就会形成作用域链.作用域链的前端就是当前执行环境,全局执行环境的变量即作用域链的顶端.在当前作用域中找不到变量时,JS引擎会沿着作用域链一级一级向上查询,直到找到为止.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中,foo的作用域中没有变量a,需要使用变量a需要向上一级查找.</p>
<h4 id="LHS-and-RHS"><a href="#LHS-and-RHS" class="headerlink" title="LHS and RHS"></a>LHS and RHS</h4><p>JS引擎进行变量查询的方式有两种,分别是LHS和RHS.LHS表示查询赋值操作的目标,RHS表示查询赋值操作的源头.简单的说,LHS查询是寻找这个变量的容器本身,从而进行赋值操作,RHS查询是查找某个变量的值.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>对上面的例子进行分析:</p>
<ul>
<li>要执行函数foo,需要知道其赋值操作的源头,从而进行RHS引用</li>
<li>接下来把数字1赋值给函数foo的形参a,需要进行一次LHS引用,这是一个隐式变量分配</li>
<li>对console进行RHS引用,console是一个内置对象,有log()方法</li>
<li>确认形参a的值,进行一次RHS查询,将形参a的值传递给console对象的log()方法</li>
</ul>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>如果RHS查询在所有的作用域链都没有找到所需的变量时,JS引擎就会抛出ReferenceError异常.如果RHS查询到目标变量,但尝试进行非法操作时,JS引擎会抛出TypeError异常.<br>如果LHS查询在所有的作用域链中都找不到所需的变量时,就会在全局作用域中创建该变量并返还给JS引擎.</p>
<blockquote>
<p>注意: 严格模式中禁止自动或隐式创建变量,LHS查询失败时同样会返回ReferenceError异常.</p>
</blockquote>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p>作用域一般有两种工作模式,一种是为大多数语言使用的词法作用域,另一种是动态作用域.</p>
<p>词法作用域就是定义在词法阶段的作用域.词法作用域是由书写代码是函数声明位置决定的.作用域一旦确定基本上会保持不变.当然也有欺骗词法的方法,但不推荐使用,欺骗作用域会导致性能下降.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域,只有foo标识符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">m</span>) </span>&#123; <span class="comment">// foo的作用域,m,n和bar三个标识符</span></span><br><span class="line">  <span class="keyword">var</span> n = m - <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x</span>) </span>&#123; <span class="comment">// bar的作用域,只有x标识符</span></span><br><span class="line">    <span class="built_in">console</span>.log(m, n, x);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(n + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h4 id="欺骗词法-eval"><a href="#欺骗词法-eval" class="headerlink" title="欺骗词法-eval"></a>欺骗词法-eval</h4><p>eval()方法会接收一个字符串作为参数,并将字符串视作代码片段进行执行.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">str,a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="string">'var b = 4'</span>, <span class="number">2</span>); <span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>严格模式下,eval()方法创建的变量不能被调用.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">str, a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="string">'var b = 4'</span>, <span class="number">2</span>); <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用eval()方法生成代码将造成性能上的损失,不推荐使用.</p>
</blockquote>
<h4 id="欺骗词法-with"><a href="#欺骗词法-with" class="headerlink" title="欺骗词法-with"></a>欺骗词法-with</h4><p>with()方法会将一个对象的引用当作作用域来处理,将对象的属性当作作用域的标识符来处理,从而创建一个新的作用域.这种方法也会使JS引擎在编译时无法对作用域进行优化,从而造成性能上的损失.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'one'</span>,</span><br><span class="line">  b: <span class="string">'two'</span>,</span><br><span class="line">  c: <span class="string">'three'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">  a = <span class="string">'four'</span>,</span><br><span class="line">  b = <span class="string">'five'</span>,</span><br><span class="line">  c = <span class="string">'seven'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>严格模式中with()方法被完全禁止.</p>
</blockquote>
<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><blockquote>
<p>属于这个函数的全部变量可以在整个函数内部或其嵌套的作用域内部使用,这即是函数的作用域.</p>
</blockquote>
<p>1.隐藏内部实现</p>
<p>函数作用域可以将声明在该函数内部的变量或函数隐藏起来,从而实现良好的设计模式.在模块和对象的API设计中,这种方法很常见也很实用.</p>
<p>下面是利用对象全局命名空间来规避冲突的方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameSpace = &#123;</span><br><span class="line">  doSomeThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  doAnotherThing: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>2.立即执行函数表达式(IIFE)</p>
<p>我们希望函数不需要函数名或者函数名不会污染所在的作用域,并且能够自动执行.这是我们可以使用IIFE来实现.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  a: <span class="string">'zero'</span>,</span><br><span class="line">  b: <span class="string">'one'</span>,</span><br><span class="line">  c: <span class="string">'two'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">global</span>) </span>&#123; <span class="comment">// 将bar对象的引用传递进去,参数命名为global</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'three'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// three</span></span><br><span class="line">  <span class="built_in">console</span>.log(global.a); <span class="comment">// zero</span></span><br><span class="line">&#125;)(bar);</span><br></pre></td></tr></table></figure>
<h4 id="块作用域-try-catch"><a href="#块作用域-try-catch" class="headerlink" title="块作用域(try..catch)"></a>块作用域(try..catch)</h4><p>ES3中规定try..catch会创建一个块级作用域,其中声明的变量仅在catch内部有效.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 正常执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(err); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<h4 id="块作用域-let"><a href="#块作用域-let" class="headerlink" title="块作用域-let"></a>块作用域-let</h4><p>ES6中引用了let关键字,可以将变量绑定到任意的作用域中.let将其声明的变量隐式的放到了它所在的块作用域中.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 正常执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用&#123;..&#125;显式声明变量</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure></p>
<h4 id="块作用域-const"><a href="#块作用域-const" class="headerlink" title="块作用域-const"></a>块作用域-const</h4><p>ES6中引入了const关键字,用来声明常量.同样可以用来创建块作用域.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">9</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>声明在这个作用域中的变量都将作用在这个作用域中.</p>
</blockquote>
<h4 id="函数和变量提升"><a href="#函数和变量提升" class="headerlink" title="函数和变量提升"></a>函数和变量提升</h4><p>作用域中的声明将在代码本身执行之前首先处理,将这个过程想象成所用声明(变量和函数)都会被移动到各自作用域的前端,这个过程称为提升.</p>
<blockquote>
<p>先有声明后有赋值.只有函数和变量会进行提升</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码,编译器会把声明var a;提升到全局顶部首先进行处理,即按照如下顺序处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有声明本身会被提升,赋值和其它逻辑语句会停留在原地</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器把var a = 0;视为两部分,即var a;和a = 0;</span></span><br><span class="line"><span class="comment">// 将var a;提升到全局顶部,首先进行处理,赋值操作a = 0;留在原地.</span></span><br><span class="line"><span class="comment">// 编译器会按照如下形式处理这段代码:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个作用域只会在自己的作用域范围内进行提升</span></span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码块中,全局作用域中的函数声明会被提升,bar函数作用域中的var a;也会被提升</span></span><br><span class="line"><span class="comment">// 即按照下面的顺序进行处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数首先会被提升,然后才是变量.要避免重复声明,当变量声明和函数声明混合在一起容易造成混乱.</p>
</blockquote>
</div><div class="entry-extra"><div class="entry-tags"></div></div></div></article></div></main><footer><div class="copyright container"></div><!--    - var currentDate = new Date();--><!--	  - var year = currentDate.getFullYear();--><!--    - var start = config.startYear;--><!--    - year = year == start ? year : (start ? start + ' - ' + year : year);--><!--    p © Copyright #{year} by #[a(href=config.url)!= config.author].	p E-mail: yie@live.cn--></footer><script async src="//cdn.bootcss.com/mathjax/2.7.0-beta.0/MathJax.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-69822347-1",'auto');
ga('set', 'appName',"yie's Blog");
ga('send','pageview');</script><script>(function () { var sid =500303098;cid =500303108;var hm = document.createElement('script');
hm.src = 'http://pingjs.qq.com/h5/stats.js';
hm.setAttribute('name', 'MTAH5'); hm.setAttribute('sid', sid); hm.setAttribute('cid', cid);
var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);
}())</script><script>var _vds = _vds || [];
window._vds = _vds;
(function(){
  ;_vds.push(['setAccountId',"90b580e047dd0007"  ]);
  (function() {
      var vds = document.createElement('script');
      vds.type='text/javascript';
      vds.async = true;
      vds.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'dn-growing.qbox.me/vds.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(vds, s);
  })();
})();</script><script async src="//raw.githack.com/Easyfood/pageAccelerator/master/dist/page-accelerator.min.js"></script><script async src="/script/loading.js"></script><script async src="/script/photo.js"></script></body></html>