<!DOCTYPE html><html prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>ECMAScript6 · 🥁 yie's Blog 🎈</title><meta name="description" content="ECMAScript6 - yie"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_1472710214_6648843.css"><link rel="stylesheet" href="//raw.githack.com/xwartz/hexo-theme-nuna/next/source/style/main.css?v=1.0.3"></head><body class="pupa"><div class="loading-bar"></div><main><div class="post post"><article itemscope itemtype="http://schema.org/Article" class="hentry"><div class="container"><div class="entry-header"><h1 class="entry-title">ECMAScript6</h1><div class="entry-description"></div><div class="entry-meta"><time itemprop="datePublished" datetime="Sunday, May 6th 2018, 11:59:53 am" class="updated">May 6, 2018</time><em class="post-count">10,720 words</em></div></div><div itemprop="articleBody" class="entry-content"><p>ECMAScript6.0(简称ES6)是JavaScript语言的下一代标准, 已经在2015年6月正式发布了. 它的目标是使JavaScript可以用来编写复杂的大型应用程序, 成为企业级开发语言. 各个浏览器对ECMAScript6的支持可以查看 <a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es6/</a>.</p>
<h4 id="Babel转码器"><a href="#Babel转码器" class="headerlink" title="Babel转码器"></a>Babel转码器</h4><p><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>是一个广泛的ECMAScript6转码器, 可以将ECMAScript6代码转为ECMAScript5代码. 通过这种方式就不用担心当前环境是否支持ECMAScript6.</p>
<p>Babel提供了一个<a href="https://babeljs.io/repl/" target="_blank" rel="noopener">REPL在线编译器</a>, 可以在线将ECMAScript6代码转为ECMAScript5代码.</p>
<p>Babel还提供了<code>Babel-cli</code>工具, 可以使用命令行转码.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm是node.js包管理工具,使用npm命令必须先安装node.js</span></span><br><span class="line"><span class="comment"># 使用npm命令安装babel-cli工具</span></span><br><span class="line">$ npm i -g babel-cli</span><br></pre></td></tr></table></figure>
<p>基本用法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转码结果输出到标准输出</span></span><br><span class="line">$ babel example.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码结果写入一个文件中</span></span><br><span class="line"><span class="comment"># -o(也可以使用--out-file参数)参数指定输出文件</span></span><br><span class="line">$ babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个目录转码</span></span><br><span class="line"><span class="comment"># -d参数(也可以使用--out-dir参数)指定输出目录</span></span><br><span class="line">$ babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s参数生成source map文件</span></span><br><span class="line">$ babel src -d lib -s</span><br></pre></td></tr></table></figure>
<h4 id="let和const关键字"><a href="#let和const关键字" class="headerlink" title="let和const关键字"></a>let和const关键字</h4><p>ECMAScript6新增了let关键字, 用来声明变量. 它的用法与var关键字类似, 但是用let关键字声明的变量, 只在let关键字所在的代码块内有效, 不会和var关键字一样发生变量提升.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript6明确规定, 区块中存在let和const关键字, 这个区块对这些声明的变量和常量, 从一开始就形成了封闭作用域. 只要在声明之前使用这些变量和常量, 就会报错.</p>
<p>在代码块中, 使用let关键字声明变量之前, 该变量是不可用的, 这在语法上称为<code>TDZ</code>(暂时性死区).</p>
<p>let关键字不允许在相同作用域中重复声明同一变量, let关键字为JavaScript新增了块级作用域, ECMAScript6引入了块级作用域, 明确允许在块级作用域中声明函数.</p>
<p>const关键字用来声明一个只读常量, 声明过后, 常量的值就不能改变. const关键字声明的常量也是不提升的, 也存在<code>TDZ</code>, 只能在声明之后使用常量.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于复合类型的常量, 常量名不指向数据, 而是指向数据所在的地址. const关键字只保证变量名指向地址不变, 并不保证该地址的数据不变.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  bar: <span class="string">'zero'</span>,</span><br><span class="line">  bingo: <span class="string">'four'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bingo = <span class="string">'two'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bingo); <span class="comment">// two</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>ECMAScript6规定var关键字和function关键字声明的全局变量, 依旧是全局对象的属性; let关键字, const关键字和class关键字声明的全局变量和常量, 不属于全局对象的属性</p>
</blockquote>
<h4 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [foo, [[bar], bingo]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(bingo); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构数组允许指定默认值</span></span><br><span class="line">[foo, bar = <span class="number">1</span>] = [<span class="number">3</span>]; <span class="comment">// foo = 3, bar = 1</span></span><br><span class="line">[foo, bar = <span class="number">1</span>] = [<span class="number">3</span>, <span class="literal">undefined</span>]; <span class="comment">// foo = 3, bar = 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>ECMAScript6内部使用严格相等相等符(===)判断一个值. 如果一个数组成员不严格等于undefined,默认值不会生效.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的解构赋值</span></span><br><span class="line"><span class="keyword">var</span> &#123; bar, foo &#125; = &#123; <span class="attr">bar</span>: <span class="string">'one'</span>, <span class="attr">foo</span>: <span class="string">'two'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// one</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// two</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">bar</span>: bingo &#125; = &#123; <span class="attr">bar</span>: <span class="string">'one'</span>, <span class="attr">foo</span>: <span class="string">'two'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bingo); <span class="comment">// one</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// error: bar is not defined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象的解构与数组有一些不同. 数组的元素是按次序排序的, 变量的取值由它的位置决定, 而对象的属性没有次序, 变量必须与属性同名, 才能取得正确值.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数的解构赋值</span></span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>], [<span class="number">7</span>, <span class="number">2</span>]].map(<span class="function"><span class="keyword">function</span>(<span class="params">[a, b]</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;); <span class="comment">// [6, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的解构赋值用作:</span></span><br><span class="line"><span class="comment">// 交换变量的值</span></span><br><span class="line"><span class="comment">// 提交JSON的值</span></span><br><span class="line"><span class="comment">// 函数参数的默认值</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// includes(): 返回布尔值, 表示是否找到参数字符串</span></span><br><span class="line"><span class="comment">// startWidth(): 返回布尔值, 表示参数字符串是否在源字符串的头部</span></span><br><span class="line"><span class="comment">// endsWidth(): 返回布尔值, 表示参数字符是否在源字符串的尾部</span></span><br><span class="line"><span class="comment">// 第二个参数n, endsWidth()方法与另两个方法不同, 它针对前n个字符</span></span><br><span class="line"><span class="comment">// 另两个方法第二个参数n针对从第n个位置直到字符串结束</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="string">'hello world!'</span>;</span><br><span class="line">bar.startWidth(<span class="string">'world'</span>, <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line">bar.endsWidth(<span class="string">'hello'</span>, <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line">bar.includes(<span class="string">'hello'</span>, <span class="number">6</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// repeat()方法返回一个新字符串, 表示将源字符串重复n次</span></span><br><span class="line"><span class="comment">// 'bingo'.repeat(2); // 'bingobingo'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// padStart()方法用于头部补全</span></span><br><span class="line"><span class="comment">// padEnd()方法用于尾部补全</span></span><br><span class="line"><span class="comment">// 第一个参数用来指定字符串的最小长度</span></span><br><span class="line"><span class="comment">// 第二个参数用来补全的字符串</span></span><br><span class="line"><span class="string">'go'</span>.padStart(<span class="number">5</span>, <span class="string">'a'</span>); <span class="comment">// 'aaago'</span></span><br><span class="line"><span class="string">'go'</span>.padStart(<span class="number">4</span>, <span class="string">'abc'</span>); <span class="comment">// 'abgo'</span></span><br><span class="line"><span class="string">'go'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>); <span class="comment">// 'goaba'</span></span><br><span class="line"><span class="string">'go'</span>.padEnd(<span class="number">3</span>,<span class="string">'abcd'</span>); <span class="comment">// 'goa'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板字符串是增强版的字符串, 用反引号标识. 它可以当作普通字符串使用</span></span><br><span class="line"><span class="comment">// 也可以用来定义多行字符串或者字符串嵌入变量</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'Mike'</span>, time = <span class="string">'today'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span>); <span class="comment">// Hello Mike, how are you today?</span></span><br></pre></td></tr></table></figure>
<h4 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h4><blockquote>
<p>在ECMAScript5开始, 严格模式中八进制不再允许使用前缀<code>0</code>表示, 要使用前缀<code>0o</code>表示</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number.isFinite()方法: 检查一个数字是否无穷(infinity)</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.0008</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number.isNaN()方法: 检查一个值是否为NaN(not a number)</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">10</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>它们与传统的全局方法isFinite()和isNaN()的区别, 传统方法先调用Number将非数值的值转为数值, 在进行判断, 这两个新方法只对数值有效, 非数值一律返回false.</p>
<p>Number.parseInt(), Number.parseFloat():<br>ECMAScript6将全局方法parseInt()和parseFloat()移植到了Number对象上, 作用完全保持不变.</p>
<p>Number.isInteger():<br>用来判断一个值是否为整数, 在JavaScript内部, 整数和浮点数是同样的存储方法, 4和4.0被视为同一个值.</p>
<p>安全整数和Number.isSafeInteger():<br>JavaScript能准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间(不含两个端点), 超过范围, 无法精确表示.</p>
<p>ECMAScript6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>两个常量, 用来表示这个范围的上下限.<br>Number.isSafeInteger()方法用来判断一个整数是否在这个范围内.</p>
<p>Math对象的扩展</p>
<ul>
<li>Math.trunc()方法用于去除一个数的小数部分, 返回整数部分.</li>
<li>Math.sign()方法用来判断一个数是正数, 负数还是零.</li>
<li>Math.cbrt()方法用来计算一个数的立方根.</li>
<li>Math.fround()方法返回一个数的单精度浮点数形式.</li>
<li>Math.hypot方法返回所有参数的平方和的平方根.</li>
</ul>
<h4 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.from()方法用于将两类对象转为真正的数组:</span></span><br><span class="line"><span class="comment">// 类似数组的对象(array-like object)和可遍历(iterable)的对象(包括新增的数据结构Set和Map)</span></span><br><span class="line"><span class="comment">// 常见的类似数组的对象是DOM操作返回的NodeList集合, 以及函数内部的arguments对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(foo).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">let</span> bingo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.of()方法: 将一组值,转为数组形式</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>); <span class="comment">// [1, 5, 8]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实例的copyWithin()方法</span></span><br><span class="line"><span class="comment">// Array.prototype.copyWithin(target, start = 0, end = this.length)</span></span><br><span class="line"><span class="comment">// 第一个参数target(必需): 从该位置开始替换数据</span></span><br><span class="line"><span class="comment">// 第二个参数start(可选): 从该位置开始读取数据,默认为0.如果为负数,表示倒数</span></span><br><span class="line"><span class="comment">// 第三个参数end(可选): 到该位置停止读取数据,默认等于数组长度.如果为负数,表示倒数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实例的find()方法: 找出第一个符合条件的数组元素</span></span><br><span class="line"><span class="comment">// 参数为一个回调函数, 所有数组元素依次执行该回调函数, 直到找到第一个返回值为true的元素, 返回该元素</span></span><br><span class="line"><span class="comment">// 没有符合条件的元素, 返回undefined</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">-8</span>, <span class="number">6</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// -8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组实例的findIndex()方法用法与find()方法类似</span></span><br><span class="line"><span class="comment">// 不过返回的是第一个符合条件的数组元素的索引, 没有符合田间的元素,返回-1</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">-8</span>, <span class="number">6</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fill()方法使用给定值, 填充一个数组</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>].fill(<span class="number">4</span>); <span class="comment">// [4, 4, 4]</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript6提供三个新方法–entries(), key()和values(), 用于遍历数组. 唯一区别是key()方法是对键名的遍历, values()方法是对键值的遍历,entries()方法是对键值对的遍历.</p>
<h4 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="comment">// ECMAScript6允许使用"箭头"( =&gt; )定义函数</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="params">a</span> =&gt;</span> a;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数注意点:</p>
<ul>
<li>函数体内的this对象, 就是定义时所在的对象, 而不是使用时所在的对象</li>
<li>不可以当作构造函数, 不可以使用new关键字创建实例对象, 否则抛出一个错误</li>
<li>不可以使用arguments对象, 该对象在函数体中不存在. 如要使用Rest参数代替</li>
<li>不可以使用yield关键字, 箭头函数不能用作Generator函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMAScript6允许给函数的参数设置默认值</span></span><br><span class="line"><span class="comment">// 函数参数的默认值直接写在参数定义的后面</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="string">'one'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定默认之后, 函数的length属性可以返回没有指定默认值的参数个数</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">1</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">2</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ECMAScript6引入rest参数(形式为'...变量名')</span></span><br><span class="line"><span class="comment">// 用于获取函数的剩余参数</span></span><br><span class="line"><span class="comment">// rest参数搭配的变量是一个数组, 该变量将剩余的参数放入数组中</span></span><br><span class="line"><span class="comment">// rest参数之后不能再有参数, 否则报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展运算符(spread)是三个点( ... )</span></span><br><span class="line"><span class="comment">// 它好比rest参数的逆运算, 将一个数组转为用逗号分隔的参数序列</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>); <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"><span class="comment">// ECMAScript5写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// ECMAScript6写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用扩展运算符合并数组</span></span><br><span class="line"><span class="keyword">var</span> arrOne = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arrTwo = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"><span class="keyword">var</span> arrThree = [<span class="string">'f'</span>];</span><br><span class="line"><span class="comment">// ECMAScript5写法</span></span><br><span class="line">arrOne.concat(arrTwo, arrThree); <span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class="line"><span class="comment">// ECMAScript6写法</span></span><br><span class="line">[...arrOne, ...arrTwo, ...arrThree] <span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用扩展字符串将字符串转为数组</span></span><br><span class="line">[...<span class="string">'bingo'</span>] <span class="comment">// ['b', 'i', 'n', 'g', 'o']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Iterator接口的对象</span></span><br><span class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.getElementById(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">var</span> arr = [...nodeList];</span><br></pre></td></tr></table></figure>
<h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMAScript6允许在对象中, 可以不写属性值</span></span><br><span class="line"><span class="comment">// 这时属性值等于属性名所代表的变量</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Mary'</span>,</span><br><span class="line">  <span class="comment">// 等同于birthday: birthday</span></span><br><span class="line">  birthday,</span><br><span class="line">  <span class="comment">// 等同于say: function () ...</span></span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'My name is'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.assign()方法用于对象的合并</span></span><br><span class="line"><span class="comment">// 将源对象(source)的所有可枚举属性, 复制到目标对象(target)</span></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> sourceOne = &#123; <span class="attr">b</span>: <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> sourceTwo = &#123; <span class="attr">c</span>: <span class="number">6</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, sourceOne, sourceTwo);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123; a: 1, b: 9, c: 6 &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果目标对象与源对象有同名属性, 或多个源对象有同名属性, 则后面的属性会覆盖前面的属性. Object.assign()方法实现的是浅拷贝, 而不是深拷贝. 如果源对象某个属性值是对象, 那目标杜希昂拷贝得到的是这个对象的引用.</p>
<p>Object.assign()方法的用处:</p>
<ul>
<li>为对象添加属性</li>
<li>为对象添加方法</li>
<li>克隆对象</li>
<li>合并多个对象</li>
<li>为属性指定默认值</li>
</ul>
<p>ECMAScript6属性的遍历方法:</p>
<ul>
<li>for..in循环遍历对象自身和继承的可枚举属性(不含Symbol属性)</li>
<li>Object.keys(obj)方法返回一个数组, 包含对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)</li>
<li>Object.getOwnPropertyNames(obj)方法返回一个数组, 包含对象自身的所有属性(包含不可枚举属性, 不含Symbol属性)</li>
<li>Object.getOwnPropertySymbols(obj)方法返回一个数组, 包含对象自身的所有Symbol属性</li>
<li>Reflect.ownKeys(obj)方法返回一个数组, 包含对象自身的所有属性, 不管是属性名是Symbol或字符串, 也不管是否可枚举</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMAScript5对象属性名都是字符串, 容易造成属性名的冲突</span></span><br><span class="line"><span class="comment">// 为了防止属性名的冲突, ECMAScript6引入了Symbol</span></span><br><span class="line"><span class="comment">// Symbol值作为对象属性名时, 不能用点运算符</span></span><br><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> bar = &#123;&#125;;</span><br><span class="line">bar.mySymbol = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar[mySymbol]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(bar[<span class="string">'mySymbol'</span>]); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>点运算符后面总是字符串, 所以不会读取mySymbol作为标识符所指代的那个值, 导致bar的属性名实际上是一个字符串, 而不是一个Symbol的值.</p>
<p>Symbol作为属性名, 该属性不出现在for..in, for..of循环中, 也不会被Object.keys()方法和Object.getOwnPropertyNames()方法返回. 但是他也不是私有属性, Object.getOwnPropertySymbols()方法可以获取指定对象的所有Symbol属性名.</p>
<p>Reflect.ownKeys()方法可以返回所有类型的键名, 包括常规键名和Symbol键名.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'obj_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span>,</span><br><span class="line">  foo: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj); <span class="comment">// [Symbol(obj_key), 'bar', 'foo']</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol.for()方法可以重新使用同一个Symbol的值</span></span><br><span class="line"><span class="comment">// 它接收一个字符串作为参数, 搜索有没有以该参数作为名称的Symbol值</span></span><br><span class="line"><span class="comment">// 如果搜索有这个值, 返回这个Symbol值</span></span><br><span class="line"><span class="comment">// 否则就新建并返回一个以该字符串为名称的Symbol值</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> symOne = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(symOne); <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">var</span> symTwo = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(symTwo); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h4><p>ECMAScript6提供了新的数据结构Set. 它类似数组, 但元素值都是唯一的, 无重复值. Set本身是一个构造函数, 可以用来生成Set数据结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>].map(<span class="function"><span class="params">a</span> =&gt;</span> bar.add(a));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> bar) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 2 5 6 1</span></span><br></pre></td></tr></table></figure>
<p>Set实例对象的属性和方法</p>
<ul>
<li>Set.prototype.constructor属性: 构造函数, 默认是Set函数</li>
<li>Set.prototype.size属性: 返回Set实例对象的成员总数</li>
<li>add(value)方法: 添加某个值, 返回Set结构本身</li>
<li>delete(value)方法: 删除某个值, 返回一个布尔值, 表示删除是否成功</li>
<li>has(value)方法: 返回一个布尔值, 表示该值是否为Set的成员</li>
<li>clear()方法: 清除所有成员, 没有返回值</li>
</ul>
<p>JavaScript对象本质上是键值对的集合(Hash结构), 传统上只能用字符串当作键, 给使用带来了限制. 为了解决这个问题, ECMAScript6提供了Map数据结构, 它类似对象, 也是键值对的集合, 但是”键”的范围不限于字符串, 各种类型的值(包括对象)都可以当作键.</p>
<p>原生Map提供三个遍历器生成函数和一个遍历方法</p>
<ul>
<li>keys(): 返回键名的遍历器</li>
<li>values(): 返回键值的遍历器</li>
<li>entries(): 返回所有成员的遍历器</li>
<li>forEach(): 遍历Map的所有成员</li>
</ul>
<h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><p>Generator函数从语法上可以把它理解成是一个状态机, 封装了多个内部状态. 执行Generator函数会返回一个遍历器对象, 他除了状态机, 还是一个遍历器对象生成函数, 返回的遍历器对象, 可以一次遍历Generator函数内部的每一个状态.</p>
<p>Generator函数形式上是一个普通函数, 但有两个特点, function关键字与函数名之间有一个星号, 函数体内部使用yield语句定义不同的内部状态.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Gener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = Gener();</span><br><span class="line">foo.next(); <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">foo.next(); <span class="comment">// &#123; value: 'world', done: fasle &#125;</span></span><br><span class="line">foo.next(); <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">foo.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* success */</span>) &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise实例对象可以使用then()方法分别指定Resolved状态和Reject状态的回调函数. then()方法可以接收两个回调函数作为参数. 第一个回调函数是Promise对象的状态变为Resolved时调用, 第二个回调函数是Promise对象的状态变为Reject时调用. 第二个回调函数是可选的, 不一定要提供, 这两个回调函数都可以接收Promise对象传出的值作为参数. then()方法返回的是一个新的Promise实例(不是原来的Promise实例), 我们可以使用链式写法, 即then()方法之后再调用另一个then()方法.</p>
<p>Promise实例对象的catch()方法, 也就是<code>.then(null, rejection)</code>的别名, 用于指定发生错误时的回调函数. 不要在then()方法里面定义Reject状态的回调函数(即then()方法的第二个参数), 而是使用catch()方法.</p>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.a + <span class="string">', '</span> + <span class="keyword">this</span>.b + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义了一个”类”, 里面有一个constructor()方法, 这就是构造函数, this关键字代表实例对象. 由于类的方法默认定义在prototype对象上面, 所以类的新方法可以添加在prototype对象上面. Object.assign()方法可以很方便一次向类添加多个方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Person.prototype, &#123;</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类内部所有定义的方法都是不可枚举的(non-enumerable).</p>
</blockquote>
<p>constructor()方法是类的默认方法, 通过new关键字创建实例对象时, 自动调用该方法. 一个类必须有constructor()方法, 如果没有显示定义, 会默认添加一个空的constructor()方法. contructor()方法默认返回的实例对象(即this)可以指定返回另一个对象.</p>
<h4 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class之间可以使用extends关键字实现继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类构造函数中, 只有调用super()方法之后, 才可以使用this关键字, 否则会报错</span></span><br><span class="line"><span class="comment">// Class不存在变量提升</span></span><br><span class="line"><span class="keyword">new</span> Person(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Object.getPrototypeOf()方法可以从子类上获取父类, 可以使用该方法判断一个类是否继承至另一个类</p>
</blockquote>
<p>super关键字</p>
<ul>
<li>作为函数调用时(即super(…args)), super代表父类的构造函数</li>
<li>作为对象调用时(即super.prop或者super.method()), super代表父类, 此时super既可以引用父类实例的属性和方法, 也可以引用父类的静态方法</li>
</ul>
<p>Class静态方法</p>
<p>类相当于实例的原型, 所有在类中定义的方法, 都会被实例继承. 在一个方法前加上static关键字, 表示该方法不会被实例继承, 而是直接通过类来调用, 这被称为<code>静态方法</code>.</p>
</div><div class="entry-extra"><div class="entry-tags"><a href="/tags/JavaScript/" class="tag">JavaScript</a></div></div></div></article></div></main><footer><div class="copyright container"></div><!--    - var currentDate = new Date();--><!--	  - var year = currentDate.getFullYear();--><!--    - var start = config.startYear;--><!--    - year = year == start ? year : (start ? start + ' - ' + year : year);--><!--    p © Copyright #{year} by #[a(href=config.url)!= config.author].	p E-mail: yie@live.cn--></footer><script async src="//cdn.bootcss.com/mathjax/2.7.0-beta.0/MathJax.js"></script><script async src="//raw.githack.com/Easyfood/pageAccelerator/master/dist/page-accelerator.min.js"></script><script async src="/script/loading.js"></script><script async src="/script/photo.js"></script></body></html>